MODULE_NAME='AMX_Intercom_UI' (DEV vdvTP_DPS[], DEV dvTP_DPS[], INTEGER nCHAN_BTN[], INTEGER nTXT_BTN[], INTEGER nDISPLAY_BTN[],INTEGER nDOOR_BTN[], INTEGER nDOOR_TXT_BTN[], INTEGER nDOOR_LVL_BTN[])
(*{{PS_SOURCE_INFO(PROGRAM STATS)                          *)
(***********************************************************)
(*  FILE CREATED ON: 02/18/2005 AT: 08:33:13               *)
(***********************************************************)
(*  FILE_LAST_MODIFIED_ON: 03/25/2011  AT: 13:22:45        *)
(***********************************************************)
(*  ORPHAN_FILE_PLATFORM: 1                                *)
(***********************************************************)
(*!!FILE REVISION: Rev 0                                   *)
(*  REVISION DATE: 02/18/2005                              *)
(*                                                         *)
(*  COMMENTS:                                              *)
(*                                                         *)
(***********************************************************)
(*}}PS_SOURCE_INFO                                         *)
(***********************************************************)

(***********************************************************)
(* System Type : Netlinx                                   *)
(***********************************************************)
(* REV HISTORY:                                            *)
(***********************************************************)
// Rev 1.9 - replaced @PPX with CLEAR_POPUPS function DJH
// moved '@PPF-_DoorAnswerCall' to avoid PPF when door is answered.

(***********************************************************)
(*          DEVICE NUMBER DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_DEVICE
(***********************************************************)
(*               CONSTANT DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_CONSTANT

(* USER-EDITABLE CONSTANTS *)

// BELOW ARE CONSTANTS THAT CAN BE EDITED BY THE USER
INTEGER nMAX_TPS = 21			// THE TOTAL NUMBER OF DEVICES SUPPORTED IN THE SYSTEM - INCLUDES 1 VIRTUAL TP
INTEGER nPB_DISPLAY_SIZE = 5		// NUMBER OF ITEMS THAT THE TOUCH PANEL CAN DISPLAY IN THE PHONEBOOK AT ONE TIME
INTEGER nDOOR_DISPLAY_SIZE = 5		// NUMBER OF DOOR BELLS THAT CAN BE DISPLAYED IN THE DOOR SETUP PAGES AT ONE TIME
INTEGER nDEFAULT_CALL_TIMEOUT = 2	// DEFAULT CALL TIMEOUT IN MINUTES
CHAR cVIDEO_DYANAMIC_IMAGE[] = 'StormVideo'// MUST MATCH THE NAME OF THE DYNAMIC IMAGE IN TOUCH PANEL DESIGNATED FOR ENTRY COMMUNICATOR VIDEO
// nPAGE_PRIORITY INDICATES IF 'PAGE ALL' HAS PRIORITY OVER ALL EXISTING CALLS AND PRIVACY OR NOT
// 1 - PAGE TERMINATES EXISTING CALLS; 0 - PAGE DOES NOT TERMINATE EXISTING CALLS
INTEGER nPAGE_PRIORITY = 0
CHAR strDoorChimeNames[6][16]=	// SELECTION OF DOOR BELL CHIMES STORED ON TOUCH PANEL
{
  'doorbell1.mp3',
  'doorbell2.wav',
  'doorbell3.wav',
  'doorbell4.wav',
  'doorbell5.wav',
  'doorbell6.wav'
}

// USER-DEFINED FOLDER STRUCTURE FOR LOCATION OF OLED DISPLAY GRAPHICS ON COMMUNICATORS
// IF DEFAULT DIRECTORY IS USED, THEN LEAVE THIS EMPTY
CHAR strDisplayLocation[16] = ''

CHAR strDisplayNames[6][16]=	// SELECTION OF GRAPHICS ALREADY LOADED ON THE COMMUNICATOR FOR OLED DISPLAY
{
    'Welcome.bmp',	// Welcome
    'DND.bmp',		// Do Not Disturb
    'MUR.bmp',		// Make Up Room
    'AMX.bmp',
    'alloff.bmp',
    'allon.bmp'
}

INTEGER nIGMP_COUNT = 5	// MAX NUMBER OF IGMP CALLS SUPPORTED

// IGMP ADDRESS FOR PAGE ALL FUNCTIONALITY - CHECK WITH YOUR IT DEPARTMENT,
// OR REFERENCE http://www.iana.org/assignments/multicast-addresses BEFORE CHANGING
CHAR cIGMP_IP_LIST[nIGMP_COUNT][11] =
{
    '239.192.0.1',
    '239.192.0.2',
    '239.192.0.3',
    '239.192.0.4',
    '239.192.0.5'
}

(* END USER-EDITABLE CONSTANT *)

DEV dvDUMMY = 0:0:0					// DUMMY DEVICE USED FOR INTIALIZING
INTEGER nMINUTE = 60000					// NUMBER OF MILLISECONDS IN A MINUTE
INTEGER nSECOND = 1000					// NUMBER OF MILLISECONDS IN A SECOND

// CALL TYPES
INTEGER NORMAL = 0
INTEGER MONITOR = 1
INTEGER VIEW = 3

// TIMELINE IDS
LONG lRING_TIMEOUT1 = 100				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT2 = 101				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT3 = 102				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT4 = 103				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT5 = 104				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT6 = 105				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT7 = 106				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT8 = 107				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT9 = 108				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT10 = 109				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT11 = 110				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT12 = 111				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT13 = 112				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT14 = 113				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT15 = 114				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT16 = 115				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT17 = 116				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT18 = 117				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT19 = 118				// TIMEOUT FOR TOUCH PANEL RING
LONG lRING_TIMEOUT20 = 119				// TIMEOUT FOR TOUCH PANEL RING

VOLATILE LONG lRING_TIMEOUT[] =
{
    lRING_TIMEOUT1, lRING_TIMEOUT2, lRING_TIMEOUT3, lRING_TIMEOUT4, lRING_TIMEOUT5,
    lRING_TIMEOUT6, lRING_TIMEOUT7, lRING_TIMEOUT8, lRING_TIMEOUT9, lRING_TIMEOUT10,
    lRING_TIMEOUT11, lRING_TIMEOUT12, lRING_TIMEOUT13, lRING_TIMEOUT14, lRING_TIMEOUT15,
    lRING_TIMEOUT16, lRING_TIMEOUT17, lRING_TIMEOUT18, lRING_TIMEOUT19, lRING_TIMEOUT20
}
LONG lTIMEOUT1 = 1					// TIMEOUT FOR ENTRY 1 IN ACTIVE CALLS LIST
LONG lTIMEOUT2 = 2					// TIMEOUT FOR ENTRY 2 IN ACTIVE CALLS LIST
LONG lTIMEOUT3 = 3					// TIMEOUT FOR ENTRY 3 IN ACTIVE CALLS LIST
LONG lTIMEOUT4 = 4					// TIMEOUT FOR ENTRY 4 IN ACTIVE CALLS LIST
LONG lTIMEOUT5 = 5					// TIMEOUT FOR ENTRY 5 IN ACTIVE CALLS LIST
LONG lTIMEOUT6 = 6					// TIMEOUT FOR ENTRY 6 IN ACTIVE CALLS LIST
LONG lTIMEOUT7 = 7					// TIMEOUT FOR ENTRY 7 IN ACTIVE CALLS LIST
LONG lTIMEOUT8 = 8					// TIMEOUT FOR ENTRY 8 IN ACTIVE CALLS LIST
LONG lTIMEOUT9 = 9					// TIMEOUT FOR ENTRY 9 IN ACTIVE CALLS LIST
LONG lTIMEOUT10 = 10					// TIMEOUT FOR ENTRY 10 IN ACTIVE CALLS LIST
LONG lTIMEOUT11 = 11					// TIMEOUT FOR ENTRY 11 IN ACTIVE CALLS LIST
LONG lTIMEOUT12 = 12					// TIMEOUT FOR ENTRY 12 IN ACTIVE CALLS LIST
LONG lTIMEOUT13 = 13					// TIMEOUT FOR ENTRY 13 IN ACTIVE CALLS LIST
LONG lTIMEOUT14 = 14					// TIMEOUT FOR ENTRY 14 IN ACTIVE CALLS LIST
LONG lTIMEOUT15 = 15					// TIMEOUT FOR ENTRY 15 IN ACTIVE CALLS LIST
LONG lTIMEOUT16 = 16					// TIMEOUT FOR ENTRY 16 IN ACTIVE CALLS LIST
LONG lTIMEOUT17 = 17					// TIMEOUT FOR ENTRY 17 IN ACTIVE CALLS LIST
LONG lTIMEOUT18 = 18					// TIMEOUT FOR ENTRY 18 IN ACTIVE CALLS LIST
LONG lTIMEOUT19 = 19					// TIMEOUT FOR ENTRY 19 IN ACTIVE CALLS LIST
LONG lTIMEOUT20 = 20					// TIMEOUT FOR ENTRY 20 IN ACTIVE CALLS LIST

VOLATILE LONG lTIMEOUT[] =
{
    lTIMEOUT1, lTIMEOUT2, lTIMEOUT3, lTIMEOUT4, lTIMEOUT5,
    lTIMEOUT6, lTIMEOUT7, lTIMEOUT8, lTIMEOUT9, lTIMEOUT10,
    lTIMEOUT11, lTIMEOUT12, lTIMEOUT13, lTIMEOUT14, lTIMEOUT15,
    lTIMEOUT16, lTIMEOUT17, lTIMEOUT18, lTIMEOUT19, lTIMEOUT20
}
(***********************************************************)
(*              DATA TYPE DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_TYPE

STRUCTURE _PHONEBOOK
{
	DEV vdvDEVICE			// VIRTUAL DEVICE ASSOCIATED WITH TOUCH PANEL
	CHAR sNAME[20]			// NAME OF THE ENTRY
	CHAR sMODEL[20]			// PANEL TYPE
	INTEGER bACTIVE_CONN		// INDICATES IF THE ENTRY HAS AN ACTIVE COMMUNICATION LINK & ITS INDEX INTO THE CALL LIST
	INTEGER nDESTINATION		// INDICATES WHICH ENTRY IN THE ARRAY IS THE DESTINATION OF THE COMM LINK
	INTEGER bCALL_PRIVACY		// INDICATES IF THE TP HAS INTERCOM PRIVACY ON OR OFF
	INTEGER bDOOR_PRIVACY		// INDICATES IF THE TP HAS DOOR PRIVACY ON OR OFF
	INTEGER nCURRENT_PAGE		// INDICATES THE CURRENT PAGE IN THE PHONE BOOK BEING DISPLAYED
}

STRUCTURE _CALLS
{
	INTEGER nSOURCE			// INDEX OF SOURCE IN vdvTP_DPS
	INTEGER nDESTINATION		// INDEX OF DESTINATION IN vdvTP_DPS - 0 INDICATES IGMP CALL
	INTEGER nTYPE			// CONNECTION TYPE: 0 - NORMAL, 1 - MONITOR, 3 - VIEW
	INTEGER nIP_ADDR		// IP ADDRESS USED IF IGMP CALL
}

STRUCTURE _MEMORY
{
	DEV vdvDEVICE			// DEVICE ID OF THE TOUCH PANEL
	CHAR sNAME[20]			// NAME OF THE ENTRY
	CHAR sMODEL[20]			// PANEL TYPE
	CHAR cIP_ADDR[15]		// IP ADDRESS OF THE ENTRY
	INTEGER bCALL_PRIVACY		// INDICATES IF THE TP HAS INTERCOM PRIVACY ON OR OFF
	INTEGER bDOOR_PRIVACY		// INDICATES IF THE TP HAS DOORBELL PRIVACY ON OR OFF
	INTEGER bAUTO_ANSWER		// INDICATES IF AUTO ANSWER IS ON OR OFF
	INTEGER bMONITORABLE		// INDICATES IF MONITORABLE IS ON OR OFF
	INTEGER bMONITOR		// INDICATES IF ABILITY TO MONITOR IS ON OR OFF
	INTEGER nCALL_TIMEOUT		// STORES THE CALL TIMEOUT SETTING OF THE PANEL
}

STRUCTURE _DOORBELL
{
    DEV vdvDEVICE			// DEVICE ID OF THE COMMUNICATOR
    CHAR sNAME[20]			// NAME OF THE ENTRY
    CHAR sMODEL[20]			// COMMUNICATOR TYPE
    CHAR cIP_ADDR[15]			// IP ADDRESS OF THE ENTRY
    INTEGER nDOOR_CHIME			// CUSTOMIZED DOOR CHIME
    INTEGER nGRAPHIC			// CUSTOMIZED DOOR OLED DISPLAY
    INTEGER nMIC_GAIN			// MICROPHONE GAIN SETTING
    INTEGER nMIC_VOL			// MICROPHONE VOLUME SETTING
    INTEGER nSLIDER_ENABLE		// INDICATES IF THE END USER IS CURRENTLY ADJUSTING EITHER THE DOOR MIC OR DOOR SPEAKER SLIDER
}
(***********************************************************)
(*               VARIABLE DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_VARIABLE

VOLATILE _CALLS uACTIVE_CALLS[nMAX_TPS]		// TRACKS THE MAX NUMBER OF ACTIVE CALLS IN THE SYSTEM
VOLATILE _PHONEBOOK uPHONE_BOOK[nMAX_TPS]	// AN ARRAY OF TOUCH PANELS IN THE SYSTEM
_MEMORY uLAST_CONNECTED[nMAX_TPS]	// NON-VOLATILE! STORES PREVIOUSLY CONNECTED TOUCH PANEL SETTINGS FOR FUTURE RE-CONNECTION USE
_DOORBELL uDOORBELLS[nMAX_TPS]		// NON-VOLATILE! STORES PREVIOUSLY CONNECTED COMMUNICATOR SETTINGS FOR FUTURE RE-CONNECTION USE
VOLATILE INTEGER nIGMP_CALL_TRACKING[nIGMP_COUNT]=// TRACKS WHICH IGMP ADDRESSES ARE CURRENTLY IN USE
{ 0, 0, 0, 0, 0 }
VOLATILE INTEGER nCURRENTLY_SELECTED[nMAX_TPS] = // INDICATES WHAT PHONE BOOK ENTRY, IF ANY, IS CURRENTLY SELECTED
{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
VOLATILE INTEGER nTP_COUNT = 0			// TOTAL NUMBER OF TOUCH PANELS PASSED IN
VOLATILE INTEGER nCOUNTER = 0			// GENERIC LOOP COUNTER
VOLATILE INTEGER bPAGE_ALL_FLAG = 0		// INDICATES WHEN PAGE ALL FUNCTIONALITY IS ACTIVE OR NOT
VOLATILE INTEGER nINCOMING_CALLER = 0		// INDICATES WHO IS CURRENTLY CALLING
VOLATILE INTEGER nDoorChimeSelected = 0		// STORES THE CURRENTLY SELECTED DOOR CHIME
VOLATILE INTEGER nDoorGraphicSelected = 0	// STORES THE CURRENTLY SELECTED DOOR GRAPHIC
VOLATILE INTEGER nDEBUG = 1			// INDICATES CURRENT DEBUGGING LEVEL
// DOOR DND ENABLES/DISABLES ALL DOOR BELL FUNCTIONALITY, WHEN TURNED ON, ALL DOORS ARE NOT AVAILABLE IN THE SYSTEM.
INTEGER nDOOR_DND = 0

VOLATILE LONG lRING[6] = {2000, 2000, 2000, 2000, 2000, 2000}

VOLATILE LONG lTIME1[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME2[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME3[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME4[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME5[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME6[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME7[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME8[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME9[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME10[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME11[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME12[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME13[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME14[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME15[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME16[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME17[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME18[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME19[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }
VOLATILE LONG lTIME20[2] = { (2 * nMINUTE) - (30 * nSECOND), (30 * nSECOND) }

VOLATILE LONG lTIME[nMAX_TPS][2]
(***********************************************************)
(*        SUBROUTINE/FUNCTION DEFINITIONS GO BELOW         *)
(***********************************************************)

(***********************************************)
(* CLEARS INTERCOM POPUPS ON A SPEC'D PANEL    *)
(***********************************************)
DEFINE_FUNCTION CLEAR_POPUPS(DEV dvTP)
{
//  Don't kill door answer popup for call hang-ups, just offline events
//  SEND_COMMAND dvTP, '@PPF-_DoorAnswerCall'
    SEND_COMMAND dvTP, '@PPF-_Doorbell Adjustments'
    SEND_COMMAND dvTP, '@PPF-_IntercomAnswerCall'
    SEND_COMMAND dvTP, '@PPF-_IntercomMonitored'
    SEND_COMMAND dvTP, '@PPF-_MoreTime'
    SEND_COMMAND dvTP, '@PPF-_NotAvailable'
    SEND_COMMAND dvTP, '@PPF-_PrivacyOn'
}

(***********************************************)
(* THIS FUNCTION ADDS A PHONEBOOK ENTRY TO THE *)
(* SPECIFIED INDEX. 			       *)
(***********************************************)
DEFINE_FUNCTION ADD_TP_PHONEBOOK_ENTRY(INTEGER nENTRY, INTEGER nINDEX)
{
    STACK_VAR INTEGER COUNT

    IF (nDEBUG > 0) { SEND_STRING 0, "'ADD_TP_PHONEBOOK_ENTRY(',ITOA(nENTRY),',',ITOA(nINDEX),')'" }
    IF (nINDEX > 0)
    {
	IF (uPHONE_BOOK[nENTRY].vdvDEVICE == dvDUMMY)
	{
	    uPHONE_BOOK[nENTRY].vdvDEVICE = vdvTP_DPS[nINDEX]
	    uPHONE_BOOK[nENTRY].sNAME = uLAST_CONNECTED[nINDEX].sNAME
	    uPHONE_BOOK[nENTRY].sMODEL = uLAST_CONNECTED[nINDEX].sMODEL
	    uPHONE_BOOK[nENTRY].bCALL_PRIVACY = uLAST_CONNECTED[nINDEX].bCALL_PRIVACY
	    uPHONE_BOOK[nENTRY].bDOOR_PRIVACY = uLAST_CONNECTED[nINDEX].bDOOR_PRIVACY

	    UPDATE_ALL_PHONEBOOKS()
	    UPDATE_ALL_DOOR_PAGES()
	}
	ELSE { SEND_STRING 0, "'WARNING: PHONE BOOK ENTRY ',ITOA(nENTRY),' IS NOT EMPTY!'" }
    }
    ELSE { SEND_STRING 0, "'WARNING: TOUCH PANEL IS NOT STORED IN MEMORY YET'" }
}

DEFINE_FUNCTION ADD_DB_PHONEBOOK_ENTRY(INTEGER nENTRY, INTEGER nINDEX)
{
    STACK_VAR INTEGER COUNT

    IF (nDEBUG > 0) { SEND_STRING 0, "'ADD_DB_PHONEBOOK_ENTRY(',ITOA(nENTRY),',',ITOA(nINDEX),')'" }
    IF (nINDEX > 0)
    {
	IF (uPHONE_BOOK[nENTRY].vdvDEVICE == dvDUMMY)
	{
	    uPHONE_BOOK[nENTRY].vdvDEVICE = vdvTP_DPS[nINDEX]
	    uPHONE_BOOK[nENTRY].sNAME = uDOORBELLS[nINDEX].sNAME
	    uPHONE_BOOK[nENTRY].sMODEL = uDOORBELLS[nINDEX].sMODEL

	    UPDATE_ALL_PHONEBOOKS()
	    UPDATE_ALL_DOOR_PAGES()
	}
	ELSE { SEND_STRING 0, "'WARNING: PHONE BOOK ENTRY ',ITOA(nENTRY),' IS NOT EMPTY!'" }
    }
    ELSE { SEND_STRING 0, "'WARNING: TOUCH PANEL IS NOT STORED IN MEMORY YET'" }
}

DEFINE_FUNCTION ANSWER_DOOR(DEV vdvTP, DEV vdvDOOR)
{
    STACK_VAR INTEGER TP_IDX
    STACK_VAR INTEGER DB_IDX

    TP_IDX = FIND_TP_CONNECTION(vdvTP)
    DB_IDX = FIND_TP_CONNECTION(vdvDOOR)
    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[TP_IDX-1])) { TIMELINE_KILL(lRING_TIMEOUT[TP_IDX-1]) }
    IF (FIND_ACTIVECALL_ENTRY(vdvTP) > 0) { END_CALL(vdvTP) }

    SEND_COMMAND dvTP_DPS[TP_IDX], "'PPOF-_DoorAnswerCall'"
    CALL_SETUP(vdvDOOR,vdvTP)
    TRANSMIT_AUDIO(vdvDOOR)
    SEND_COMMAND dvTP_DPS[TP_IDX], "'^TXT-',ITOA(nDOOR_TXT_BTN[2]),',0,',uDOORBELLS[DB_IDX].sNAME"
    SEND_COMMAND dvTP_DPS[TP_IDX], "'PAGE-SomeoneAtTheDoor'"
    UPDATE_ALL_PHONEBOOKS()

    SEND_LEVEL dvTP_DPS[TP_IDX], nDOOR_LVL_BTN[1], uDOORBELLS[DB_IDX].nMIC_GAIN
    SEND_LEVEL dvTP_DPS[TP_IDX], nDOOR_LVL_BTN[2], uDOORBELLS[DB_IDX].nMIC_VOL
    [dvTP_DPS[TP_IDX], nDOOR_BTN[16]] = (uDOORBELLS[DB_IDX].nMIC_VOL == 0)
    [dvTP_DPS[TP_IDX], nDOOR_BTN[19]] = (uDOORBELLS[DB_IDX].nMIC_GAIN == 0)
}

(***********************************)
(* THIS FUNCTION ESTABLISHES A     *)
(* BROADCAST CALL TO ALL TPS. ANY  *)
(* CALLS ALREADY IN PROGRESS ARE   *)
(* TORN DOWN AND REPLACED WITH THE *)
(* BROADCAST CALL.		   *)
(***********************************)
DEFINE_FUNCTION BROADCAST(DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX	// PHONE BOOK ENTRY FOR TALKER TP
    STACK_VAR INTEGER TP_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR TALKER TP

    IF (nDEBUG > 0) {SEND_STRING 0, "'BROADCAST(',ITOA(vdvTP.Number),')'"}

    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)
    IF (PB_IDX > 0 && TP_IDX > 0)
    {
	STACK_VAR INTEGER N 		// LOOP COUNTER
	STACK_VAR INTEGER nENTRY	// AVAILABLE ENTRY IN ACTIVE_CALLS LIST
	STACK_VAR INTEGER nADDR		// INDEX TO THE IGMP ADDRESS TO USE

	nENTRY = 0
	FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
	{	// GET FIRST EMPTY SLOT IN ACTIVE CALLS LIST
	    IF (uACTIVE_CALLS[N].nSOURCE == 0 && nENTRY == 0)
	    {
		nENTRY = N
		BREAK
	    }
	}

	nADDR = 0
	nADDR = FIND_IGMP_ADDR()
	IF (nENTRY != 0 && nADDR != 0)	// AVAILABLE ENTRY IN uACTIVE_CALLS FOUND AND AVAILABLE IGMP ADDRESS
	{
	    STACK_VAR INTEGER IDX

	    // UPDATE PHONE BOOK TO INDICATE BUSY TPS
	    uPHONE_BOOK[PB_IDX].bACTIVE_CONN = nENTRY
	    uPHONE_BOOK[PB_IDX].nDESTINATION = 0
	    // UPDATE ACTIVE CALLS LIST
	    uACTIVE_CALLS[nENTRY].nSOURCE = TP_IDX
	    uACTIVE_CALLS[nENTRY].nDESTINATION = 0
	    uACTIVE_CALLS[nENTRY].nTYPE = 0
	    uACTIVE_CALLS[nENTRY].nIP_ADDR = nADDR

	    FOR(N = 1; N <= nTP_COUNT; N++)
	    {
		// IF PRIORITY PAGE IS ON, THEN WE DO NOT CARE ABOUT EXISTING CALLS OR PRIVACY
		// IF PRIORITY PAGE IS OFF, THEN WE DO NOT INTERRUPT EXISTING CALLS OR OVERRIDE PRIVACY
		IF ((nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != vdvTP && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY) ||
		    (!nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != vdvTP && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY &&
		    uPHONE_BOOK[N].bACTIVE_CONN == 0 && !uPHONE_BOOK[N].bCALL_PRIVACY))
		{	// PAGE DOES NOT GO TO ENTRY COMMUNICATORS
		    IF (LEFT_STRING(uPHONE_BOOK[N].sMODEL,3) != 'MET')
		    {
			IDX = FIND_TP_CONNECTION(uPHONE_BOOK[N].vdvDEVICE)
//~~~ v1.10 sends wrong source name, also redundant:
//			SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Receiving page from ',uLAST_CONNECTED[PB_IDX].sNAME"
			SEND_COMMAND uPHONE_BOOK[N].vdvDEVICE, "'RECEIVE_PAGE-',cIGMP_IP_LIST[nADDR]"

			uPHONE_BOOK[N].bACTIVE_CONN = nENTRY
			uPHONE_BOOK[N].nDESTINATION = TP_IDX
		    }
		}
	    }
	    SEND_COMMAND vdvTP_DPS[TP_IDX], "'SEND_PAGE-',cIGMP_IP_LIST[nADDR]"
	}
	ELSE
	{
	    IF (nDEBUG > 0){ SEND_STRING 0, 'WARNING: NO AVAILABLE ENTRY IN ACTIVE CALL LIST' }
	}
    }
    ELSE
    {
	IF (nDEBUG > 0) { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
    }
}

DEFINE_FUNCTION BROADCAST_TEARDOWN(DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX	// ENTRY IN PHONE BOOK FOR SPECIFIED DEVICE
    STACK_VAR INTEGER TP_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR TALKER TP

    IF (nDEBUG > 0) { SEND_STRING 0, "'BROADCAST_TEARDOWN(',ITOA(vdvTP.Number),')'" }

    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)
    IF (PB_IDX > 0 && TP_IDX > 0)
    {
	STACK_VAR INTEGER nENTRY	// ENTRY IN ACTIVE CALLS TO RELEASE

	nENTRY = FIND_ACTIVECALL_ENTRY(vdvTP)
	IF (uACTIVE_CALLS[nENTRY].nSOURCE != TP_IDX) { nENTRY = 0 }	// ONLY CALL ORIGINATOR CAN TEAR DOWN CALL

	IF (nENTRY != 0)	// CALL FOUND
	{
	    STACK_VAR INTEGER N 		// LOOP COUNTER
	    STACK_VAR INTEGER IDX

	    FOR (N = 1; N <= nTP_COUNT; N++)
	    {
		IF ((nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY AND uPHONE_BOOK[N].vdvDEVICE != vdvTP) ||
		    (!nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY AND uPHONE_BOOK[N].vdvDEVICE != vdvTP &&
		    uPHONE_BOOK[N].nDESTINATION == TP_IDX))
		{	// IGNORE ENTRY COMMUNICATORS
		    IF (LEFT_STRING(uPHONE_BOOK[N].sMODEL,3) != 'MET')
		    {
			// UPDATE PHONE BOOK ENTRY
			uPHONE_BOOK[N].bACTIVE_CONN = 0
			uPHONE_BOOK[N].nDESTINATION = 0
			SEND_COMMAND uPHONE_BOOK[N].vdvDEVICE, 'END_CALLS'
			IDX = FIND_TP_CONNECTION(uPHONE_BOOK[N].vdvDEVICE)
			SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		    }
		}
	    }
	    SEND_COMMAND vdvTP_DPS[TP_IDX], 'END_CALLS'
	    SEND_COMMAND dvTP_DPS[TP_IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
	    // UPDATE ACTIVE CALL LIST
	    uACTIVE_CALLS[nENTRY].nSOURCE = 0
	    uACTIVE_CALLS[nENTRY].nDESTINATION = 0
	    nIGMP_CALL_TRACKING[uACTIVE_CALLS[nENTRY].nIP_ADDR] = 0
	    uACTIVE_CALLS[nENTRY].nIP_ADDR = 0
	    uACTIVE_CALLS[nENTRY].nTYPE = 0
	    // UPDATE PHONE BOOK ENTRY
	    uPHONE_BOOK[PB_IDX].bACTIVE_CONN = 0
	    uPHONE_BOOK[PB_IDX].nDESTINATION = 0

	    IF (TIMELINE_ACTIVE(lTIMEOUT[nENTRY])) { TIMELINE_KILL(lTIMEOUT[nENTRY]) }
	}
	ELSE
	{
	    IF (nDEBUG > 0) { SEND_STRING 0, 'WARNING: NO ACTIVE CALL FOUND IN LIST' }
	}
    }
    ELSE
    {
	IF (nDEBUG > 0) { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
    }
}

(**************************************************)
(* THIS FUNCTION SETS UP A CALL BETWEEN TWO TPS.  *)
(* IT ALSO CONTROLS THE STATUS ICON ON THE TP 	  *)
(* SCREENS.					  					  *)
(**************************************************)
DEFINE_FUNCTION CALL_SETUP(DEV vdvTP_SOURCE, DEV vdvTP_DEST)
{
    STACK_VAR INTEGER PB_IDX1, PB_IDX2	// PHONE BOOK ENTRY INDEXES OF THE TWO TPS PASSED IN
    STACK_VAR INTEGER TP_IDX1, TP_IDX2	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR TALKER TP

    IF (nDEBUG > 0) { SEND_STRING 0, "'CALL SETUP(',ITOA(vdvTP_SOURCE.Number),',',ITOA(vdvTP_DEST.Number),')'" }

    PB_IDX1 = FIND_PHONEBOOK_ENTRY(vdvTP_SOURCE)
    PB_IDX2 = FIND_PHONEBOOK_ENTRY(vdvTP_DEST)
    TP_IDX1 = FIND_TP_CONNECTION(vdvTP_SOURCE)
    TP_IDX2 = FIND_TP_CONNECTION(vdvTP_DEST)
    IF (PB_IDX1 > 0 && PB_IDX2 > 0 && TP_IDX1 > 0 && TP_IDX2 > 0)
    {
	STACK_VAR INTEGER nENTRY		// AVAILABLE ENTRY IN ACTIVE_CALLS LIST
	STACK_VAR INTEGER N 			// LOOP COUNTER

	nENTRY = 0

	FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
	{	// GET FIRST EMPTY SLOT IN ACTIVE CALLS LIST
	    IF (uACTIVE_CALLS[N].nSOURCE == 0 && nENTRY == 0)
	    {
		nENTRY = N
		BREAK
	    }
	}
	IF (nENTRY != 0)	// AVAILABLE ENTRY IN uACTIVE_CALLS FOUND
	{
	    // UPDATE PHONE BOOK TO INDICATE BUSY TPS
	    uPHONE_BOOK[PB_IDX1].bACTIVE_CONN = nENTRY
	    uPHONE_BOOK[PB_IDX1].nDESTINATION = TP_IDX2
	    uPHONE_BOOK[PB_IDX2].bACTIVE_CONN = nENTRY
	    uPHONE_BOOK[PB_IDX2].nDESTINATION = TP_IDX1
	    // UPDATE ACTIVE CALLS LIST
	    uACTIVE_CALLS[nENTRY].nSOURCE = TP_IDX1
	    uACTIVE_CALLS[nENTRY].nDESTINATION = TP_IDX2
	    uACTIVE_CALLS[nENTRY].nTYPE = 0

	    // source is a touch panel
	    IF (uLAST_CONNECTED[TP_IDX1].vdvDEVICE != dvDUMMY)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX2], "'CREATE_CALL-SOURCE,',uLAST_CONNECTED[TP_IDX1].cIP_ADDR"
	    }
	    // source is a doorbell
	    ELSE IF (uDOORBELLS[TP_IDX1].vdvDEVICE != dvDUMMY)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX2], "'CREATE_CALL-SOURCE,',uDOORBELLS[TP_IDX1].cIP_ADDR"
	    }

	    // destination is a touch panel
	    IF (uLAST_CONNECTED[TP_IDX2].vdvDEVICE != dvDUMMY)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX1], "'CREATE_CALL-DESTINATION,',uLAST_CONNECTED[TP_IDX2].cIP_ADDR"

		IF (uDOORBELLS[TP_IDX1].vdvDEVICE != dvDUMMY)	// if source is a doorbell
		{
		    SEND_COMMAND dvTP_DPS[TP_IDX2],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H',uDOORBELLS[TP_IDX1].cIP_ADDR,'%Fstream_cam_wg.mjpeg%R10'"
		    SEND_COMMAND dvTP_DPS[TP_IDX2],"'^RFR-',cVIDEO_DYANAMIC_IMAGE"
		    SEND_COMMAND dvTP_DPS[TP_IDX2],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%P',cVIDEO_DYANAMIC_IMAGE"
		}
	    }
	    ELSE
	    {
		IF (nDEBUG > 0){ SEND_STRING 0, 'WARNING: ENTRY COMMUNICATORS SHOULD NEVER BE THE DESTINATION OF A CALL; ONLY THE SOURCE.' }
	    }
	}
	ELSE
	{
	    IF (nDEBUG > 0){ SEND_STRING 0, 'WARNING: NO AVAILABLE ENTRIES IN ACTIVE CALL LIST' }
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){ SEND_STRING 0, 'WARNING: ONE OR MORE TPs ARE NOT IN THE PHONE BOOK' }
    }
}

(*****************************************************)
(* THIS FUNCTION DISPLAYS THE SPECIFIED PAGE OF THE  *)
(* PHONE BOOK ON THE SPECIFIED DEVICE. CARE IS TAKEN *)
(* NOT TO DISPLAY THE NAME OF THE TOUCH PANEL ON     *)
(* WHICH THE PHONE BOOK IS BEING DISPLAYED.          *)
(*****************************************************)
DEFINE_FUNCTION DISPLAY_PAGE(DEV vdvTP, INTEGER nPAGE)
{
    STACK_VAR INTEGER nENTRY	// ENTRY IN PHONE BOOK CONTAINING THIS DEVICE
    STACK_VAR DEV dvTP

    dvTP = dvTP_DPS[FIND_TP_CONNECTION(vdvTP)]

    IF (nDEBUG > 0) {SEND_STRING 0, "'DISPLAY_PAGE(',ITOA(vdvTP.Number),',',ITOA(nPAGE),')'"}
    nENTRY = FIND_PHONEBOOK_ENTRY(vdvTP)
    IF (nENTRY > 0)
    {
	STACK_VAR INTEGER nCOUNT	// LOOP COUNTER
	STACK_VAR INTEGER nSTART	// SPOT IN PHONE BOOK TO START DISPLAYING
	STACK_VAR INTEGER nEND		// SPOT IN PHONE BOOK TO STOP DISPLAYING
	STACK_VAR INTEGER nLIST_ITEM	// WHICH LIST SLOT TO DISPLAY TEXT IN

	nSTART = (nPAGE * nPB_DISPLAY_SIZE) - nPB_DISPLAY_SIZE + 1
	nEND = nPAGE * nPB_DISPLAY_SIZE
	IF (nENTRY < nSTART)	// THIS TP's NAME WAS ON A PREVIOUS PAGE
	{
	    nSTART++
	    nEND++
	}
	ELSE IF (nENTRY >= nSTART && nENTRY <= nEND) { nEND++  }	// THIS TP's NAME IS ON THIS PAGE

	IF (nEND > nTP_COUNT) { nEND = nTP_COUNT }// CHECK FOR HALF PAGE

	FOR (nCOUNT = 1; nCOUNT <= nPB_DISPLAY_SIZE; nCOUNT++)
	{
	    SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[nCOUNT]), ',0,'"
	    OFF[dvTP, nDISPLAY_BTN[((nCOUNT-1)*3 + 1)]]
	    OFF[dvTP, nDISPLAY_BTN[((nCOUNT-1)*3 + 2)]]
	    OFF[dvTP, nDISPLAY_BTN[((nCOUNT-1)*3 + 3)]]
	}

	nLIST_ITEM = 1
	FOR (nCOUNT = nSTART; nCOUNT <= nEND; nCOUNT++)
	{
	    // DON'T DISPLAY HOST TP IN LIST
	    // DO NOT DISPLAY UN-REGISTERED TOUCH PANELS
	    IF (uPHONE_BOOK[nCOUNT].vdvDEVICE != dvDUMMY && uPHONE_BOOK[nCOUNT].vdvDEVICE != vdvTP && nENTRY!=nCOUNT)
	    {
		STACK_VAR CHAR sNAME[20]

		IF (uPHONE_BOOK[nCOUNT].bCALL_PRIVACY == 1)	// PRIVACY BUTTON ON
		{
		    ON[dvTP, nDISPLAY_BTN[((nLIST_ITEM-1)*3 + 2)]]
		}
		ELSE IF (LEFT_STRING(uPHONE_BOOK[nCOUNT].sMODEL,3) == 'MET')
		{
		    IF (nDOOR_DND) { ON[dvTP, nDISPLAY_BTN[((nLIST_ITEM-1)*3 + 2)]] }	// DISPLAY DND FOR DOORBELLS
		}

		IF (uPHONE_BOOK[nCOUNT].bACTIVE_CONN > 0)	// ACTIVE CONNECTION
		{	// MONITOR OR VIEW CALLS
		    IF (uACTIVE_CALLS[uPHONE_BOOK[nCOUNT].bACTIVE_CONN].nTYPE == 1 || uACTIVE_CALLS[uPHONE_BOOK[nCOUNT].bACTIVE_CONN].nTYPE == 3)
		    {
			ON[dvTP, nDISPLAY_BTN[((nLIST_ITEM-1)*3 + 3)]]
		    }
		    ELSE { ON[dvTP, nDISPLAY_BTN[((nLIST_ITEM-1)*3 + 1)]] }
		}

		IF (uPHONE_BOOK[nCOUNT].sNAME == '' && uPHONE_BOOK[nCOUNT].vdvDEVICE != dvDUMMY)
		{
		    uPHONE_BOOK[nCOUNT].sNAME = "'PANEL ',ITOA(uPHONE_BOOK[nCOUNT].vdvDEVICE.NUMBER)"
		}
		SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[nLIST_ITEM]),',0,', uPHONE_BOOK[nCOUNT].sNAME"
		nLIST_ITEM++
	    }
	}
    }
    ELSE { IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'"} }
}

(******************************)
(* TERMINATE A CALL FOR THE   *)
(* SPECIFIED TP AND ITS DEST. *)
(******************************)
DEFINE_FUNCTION END_CALL(DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX	// ENTRY IN PHONE BOOK FOR SPECIFIED DEVICE
    STACK_VAR INTEGER TP_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR SPECIFIED DEVICE

    IF (nDEBUG > 0) {SEND_STRING 0, "'END_CALL(',ITOA(vdvTP.Number),')'"}
    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)
    IF (PB_IDX > 0 && TP_IDX > 0)
    {
	STACK_VAR INTEGER nENTRY	// ACTIVE CALL INDEX

	nENTRY = FIND_ACTIVECALL_ENTRY(vdvTP)
	IF (nENTRY > 0)
	{
	    STACK_VAR INTEGER nDEST	// ENTRY IN PHONE BOOK FOR DESTINATION
	    STACK_VAR INTEGER AC_IDX	// CHECK FOR OTHER CALLS

	    nDEST = uACTIVE_CALLS[nENTRY].nDESTINATION
	    IF (nDEST == TP_IDX) { nDEST = uACTIVE_CALLS[nENTRY].nSOURCE }

	    IF (LEFT_STRING(uLAST_CONNECTED[TP_IDX].sMODEL,3) != 'MET' && uLAST_CONNECTED[TP_IDX].sMODEL != '')
	    {
		CLEAR_POPUPS(dvTP_DPS[TP_IDX])
		SEND_COMMAND dvTP_DPS[TP_IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H127.0.0.1%Ftemp.mjpg%R10'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
		SEND_COMMAND dvTP_DPS[TP_IDX],'PAGE-Intercomm Demo'
	    }
	    IF (LEFT_STRING(uLAST_CONNECTED[nDEST].sMODEL,3) != 'MET'  && uLAST_CONNECTED[nDEST].sMODEL != '')
	    {
		CLEAR_POPUPS(dvTP_DPS[nDEST])
		SEND_COMMAND dvTP_DPS[nDEST], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		SEND_COMMAND dvTP_DPS[nDEST],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H127.0.0.1%Ftemp.mjpg%R10'";
		SEND_COMMAND dvTP_DPS[nDEST],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
		SEND_COMMAND dvTP_DPS[nDEST],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'";
		SEND_COMMAND dvTP_DPS[nDEST],"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
		SEND_COMMAND dvTP_DPS[nDEST],"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
		SEND_COMMAND dvTP_DPS[nDEST],'PAGE-Intercomm Demo'
	    }

	    IF (uACTIVE_CALLS[nENTRY].nTYPE == 1)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX], 'END_MONITOR'	// END CALL
		SEND_COMMAND vdvTP_DPS[nDEST], 'END_MONITOR'	// END CALL
	    }
	    ELSE IF (uACTIVE_CALLS[nENTRY].nTYPE == 3)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX], 'END_VIEW'	// END CALL
		SEND_COMMAND vdvTP_DPS[nDEST], 'END_VIEW'	// END CALL
	    }
	    ELSE
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX], 'END_CALLS'	// END CALL
		SEND_COMMAND vdvTP_DPS[nDEST], 'END_CALLS'	// END CALL
	    }

	    // UPDATE ACTIVE CALL LIST
	    uACTIVE_CALLS[nENTRY].nSOURCE = 0
	    uACTIVE_CALLS[nENTRY].nDESTINATION = 0
	    uACTIVE_CALLS[nENTRY].nIP_ADDR = 0
	    uACTIVE_CALLS[nENTRY].nTYPE = 0

	    // UPDATE PHONE BOOK ENTRIES FOR BOTH TPS
	    uPHONE_BOOK[PB_IDX].bACTIVE_CONN = 0
	    uPHONE_BOOK[PB_IDX].nDESTINATION = 0
	    uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nDEST])].bACTIVE_CONN = 0
	    uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nDEST])].nDESTINATION = 0

	    // CHECK FOR OTHER CALLS
//	    AC_IDX = FIND_ACTIVECALL_ENTRY(vdvTP_DPS[nDEST])
//	    IF (AC_IDX > 0)
	    {
//		uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nDEST])].bACTIVE_CONN = AC_IDX
//		uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nDEST])].nDESTINATION = uACTIVE_CALLS[AC_IDX].nDESTINATION
	    }

	    IF (TIMELINE_ACTIVE(lTIMEOUT[nENTRY])) { TIMELINE_KILL(lTIMEOUT[nENTRY]) }
	}// END IF (uPHONE_BOOK[PB_IDX].bACTIVE_CONN > 0)
	ELSE
	{
	    IF (nDEBUG > 0) { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' IS NOT IN AN ACTIVE CALL'" }
	}
    }// END IF (PB_IDX > 0 && TP_IDX > 0)
    ELSE
    {
	IF (nDEBUG > 0) { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' IS NOT IN THE PHONE BOOK'" }
    }
}

DEFINE_FUNCTION END_ALL_CALLS(DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX	// ENTRY IN PHONE BOOK FOR SPECIFIED DEVICE
    STACK_VAR INTEGER TP_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR SPECIFIED DEVICE

    IF (nDEBUG > 0) {SEND_STRING 0, "'END_ALL_CALLS(',ITOA(vdvTP.Number),')'"}
    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)

    IF (PB_IDX > 0 && TP_IDX > 0)
    {
	STACK_VAR INTEGER nDEST		// ENTRY IN dvTP_DPS/vdvTP_DPS FOR DESTINATION
	STACK_VAR INTEGER nSOURCE	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR SOURCE
	STACK_VAR INTEGER nENTRY	// ENTRY IN ACTIVE CALLS TO RELEASE
	STACK_VAR INTEGER AC_IDX	// CHECK FOR OTHER CALLS

	nENTRY = FIND_ACTIVECALL_ENTRY(vdvTP)
	WHILE(nENTRY)
	{
	    nDEST = uACTIVE_CALLS[nENTRY].nDESTINATION
	    nSOURCE = uACTIVE_CALLS[nENTRY].nSOURCE

	    IF (uACTIVE_CALLS[nENTRY].nTYPE == 3) { VIEW_TEARDOWN(vdvTP_DPS[TP_IDX]) }
	    ELSE
	    {
		IF (nSOURCE == TP_IDX) { END_CALL(vdvTP_DPS[nSOURCE]) }
		ELSE { END_CALL(vdvTP_DPS[nDEST]) }
	    }

	    IF (TIMELINE_ACTIVE(lTIMEOUT[nENTRY])) { TIMELINE_KILL(lTIMEOUT[nENTRY]) }

	    nENTRY = FIND_ACTIVECALL_ENTRY(vdvTP)
	}// END WHILE(FIND_ACTIVECALL_ENTRY(vdvTP))
    }// END IF (PB_IDX > 0 && TP_IDX > 0)
    ELSE
    {
	IF (nDEBUG > 0) { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' IS NOT IN THE PHONE BOOK'" }
    }
}

(*******************************************************)
(* FIND THE APPROPRIATE ENTRY IN THE ACTIVE CALLS LIST *)
(* FOR THE SPECIFIED TP.  IF NO ENTRY IS FOUND, RETURN *)
(* 0, OTHERWISE, RETURN THE INDEX OF THE ENTRY.        *)
(*******************************************************)
DEFINE_FUNCTION INTEGER FIND_ACTIVECALL_ENTRY(DEV vdvTP)
{
    IF (vdvTP != dvDUMMY)
    {
	STACK_VAR INTEGER nINDEX	// dvTP'S INDEX IN THE PHONE BOOK LIST
	STACK_VAR INTEGER nENTRY	// LOCATION IN ACTIVE CALL LIST

	IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_ACTIVECALL_ENTRY(',ITOA(vdvTP.Number),')'" }
	nINDEX = FIND_TP_CONNECTION(vdvTP)

	IF (nINDEX > 0)
	{
	    STACK_VAR INTEGER N		// LOOP COUNTER

	    nENTRY = 0
	    FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
	    {
		IF (uACTIVE_CALLS[N].nSOURCE == nINDEX || uACTIVE_CALLS[N].nDESTINATION == nINDEX)
		{
		    nENTRY = N
		    BREAK
		}
		// FIND PAGE ALL CALLS
		ELSE IF (uACTIVE_CALLS[N].nSOURCE != 0 && uACTIVE_CALLS[N].nDESTINATION == 0 && uACTIVE_CALLS[N].nTYPE != 3)
		{
		    nENTRY = N
		    BREAK
		}
	    }
	    IF ( nENTRY > 0 )
	    {
		IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_ACTIVECALL_ENTRY RETURNING ',itoa(nENTRY)" }
		RETURN nENTRY
	    }
	    ELSE
	    {
		IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: COULD NOT FIND DEVICE ',ITOA(vdvTP.Number),' IN ACTIVE CALLS.'"}
		RETURN 0
	    }
	}
	ELSE
	{
	    IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: DEVICE ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'"}
	    RETURN 0
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: INVALID DEVICE ',ITOA(vdvTP.Number)"}
	RETURN 0
    }
}

DEFINE_FUNCTION INTEGER FIND_ACTIVE_VIEW(DEV vdvDOORBELL)
{
    IF (vdvDOORBELL != dvDUMMY)
    {
	STACK_VAR INTEGER nINDEX	// dvTP'S INDEX IN THE PHONE BOOK LIST
	STACK_VAR INTEGER nENTRY	// LOCATION IN ACTIVE CALL LIST

	IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_ACTIVE_VIEW(',ITOA(vdvDOORBELL.Number),')'" }
	nINDEX = FIND_TP_CONNECTION(vdvDOORBELL)
	IF (nINDEX > 0)
	{
	    STACK_VAR INTEGER N		// LOOP COUNTER

	    nENTRY = 0
	    FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
	    {	// FIND VIEW CALLS
		IF (uACTIVE_CALLS[N].nSOURCE == nINDEX && uACTIVE_CALLS[N].nDESTINATION == 0 && uACTIVE_CALLS[N].nTYPE == 3)
		{
		    nENTRY = N
		    BREAK
		}
	    }
	    IF ( nENTRY > 0 )
	    {
		IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_ACTIVE_VIEW RETURNING ',itoa(nENTRY)" }
		RETURN nENTRY
	    }
	    ELSE
	    {
		IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: COULD NOT FIND DEVICE ',ITOA(vdvDOORBELL.Number),' IN ACTIVE VIEWS.'"}
		RETURN 0
	    }
	}
	ELSE
	{
	    IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: DEVICE ',ITOA(vdvDOORBELL.Number),' NOT FOUND IN PHONE BOOK'"}
	    RETURN 0
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: INVALID DEVICE ',ITOA(vdvDOORBELL.Number)"}
	RETURN 0
    }
}

DEFINE_FUNCTION INTEGER FIND_DOORBELL_ENTRY(DEV vdvTP)
{
    IF (vdvTP != dvDUMMY)
    {
	STACK_VAR INTEGER N	// LOOP COUNTER

	IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_PHONEBOOK_ENTRY(',ITOA(vdvTP.Number),')'" }
	FOR (N = 1; N <= MAX_LENGTH_ARRAY(uDOORBELLS); N++)
	{
	    IF (uDOORBELLS[N].vdvDEVICE == vdvTP) { BREAK }
	}
	IF ( N <= nTP_COUNT )
	{
	    IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_PHONEBOOK_ENTRY RETURNING ',itoa(N)" }
	    RETURN N
	}
	ELSE
	{
	    IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: COULD NOT FIND DEVICE ',ITOA(vdvTP.Number),' IN DOORBELL LISTING.'"}
	    RETURN 0
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: INVALID DEVICE ',ITOA(vdvTP.Number)"}
	RETURN 0
    }
}

(********************************************)
(* THIS FUNCTION LOCATES AN UN-USED IGMP IP *)
(* ADDRESS IF ONE IS AVAILABLE AND RETURNS  *)
(* THE INDEX TO THAT IP ADDRESS.	    *)
(********************************************)
DEFINE_FUNCTION INTEGER FIND_IGMP_ADDR()
{
    STACK_VAR INTEGER RESULT
    STACK_VAR INTEGER I 	// LOOP COUNTER

    RESULT = 0
    FOR (I = 1; I <= MAX_LENGTH_ARRAY(cIGMP_IP_LIST); I++)
    {
	IF (nIGMP_CALL_TRACKING[I] == 0)
	{
	    RESULT = I
	    BREAK;
	}
    }
    RETURN RESULT
}

(********************************************)
(* THIS FUNCTION LOCATES THE ENTRY IN THE   *)
(* PHONE BOOK ARRAY THAT MATCHES THE DEVICE *)
(* PASSED IN AND RETURNS THE INDEX FOR THAT *)
(* ENTRY.                                   *)
(********************************************)
DEFINE_FUNCTION INTEGER FIND_PHONEBOOK_ENTRY(DEV vdvTP)
{
    IF (vdvTP != dvDUMMY)
    {
	STACK_VAR INTEGER N	// LOOP COUNTER

	IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_PHONEBOOK_ENTRY(',ITOA(vdvTP.Number),')'" }
	FOR (N = 1; N <= nTP_COUNT; N++)
	{
	    IF (uPHONE_BOOK[N].vdvDEVICE == vdvTP) { BREAK }
	}
	IF ( N <= nTP_COUNT )
	{
	    IF (nDEBUG > 0) { SEND_STRING 0, "'FIND_PHONEBOOK_ENTRY RETURNING ',itoa(N)" }
	    RETURN N
	}
	ELSE
	{
	    IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: COULD NOT FIND DEVICE ',ITOA(vdvTP.Number),' IN PHONE BOOK.'"}
	    RETURN 0
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: INVALID DEVICE ',ITOA(vdvTP.Number)"}
	    RETURN 0
    }
}

DEFINE_FUNCTION INTEGER FIND_TP_CONNECTION(DEV vdvTP)
{
	IF (vdvTP != dvDUMMY)
	{
		STACK_VAR INTEGER COUNT

		FOR(COUNT = 1; COUNT <= nTP_COUNT; COUNT++)
		{
			IF (vdvTP_DPS[COUNT] == vdvTP)
			{
				RETURN COUNT
			}
		}
		SEND_STRING 0, "'WARNING: TOUCH PANEL ',ITOA(vdvTP.Number),' IS NOT ACCEPTABLE'"
		RETURN 0
	}
	ELSE
	{
		SEND_STRING 0, "'WARNING: INVALID DEVICE ',ITOA(vdvTP.Number)"
		RETURN 0
	}
}

(*******************************************************)
(* THIS FUNCTION INDICATES AN ERROR HAS OCCURRED WHEN  *)
(* A USER SELECTS AN ALREADY ACTIVE TOUCH PANEL TO     *)
(* COMMUNICATE WITH.                                   *)
(*******************************************************)
DEFINE_FUNCTION INDICATE_ERROR(DEV vdvTP, INTEGER nITEM)
{
    STACK_VAR INTEGER IDX

    IDX = FIND_TP_CONNECTION(vdvTP)
    IF (nDEBUG > 0) { SEND_STRING 0, "'INDICATE_ERROR(',ITOA(vdvTP.Number),',',ITOA(nITEM),')'" }
    SEND_COMMAND dvTP_DPS[IDX], "'ADBEEP'"
    IF (nITEM > 0)
    {
	SEND_COMMAND dvTP_DPS[IDX], "'^BCB-',ITOA(nTXT_BTN[nITEM]),',1,Red'"
	WAIT 5
	{
	    SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(vdvTP)], "'^BCB-',ITOA(nTXT_BTN[nITEM]),',1,White'"
	    WAIT 5
	    {
		SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(vdvTP)], "'ADBEEP'"
		SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(vdvTP)], "'^BCB-',ITOA(nTXT_BTN[nITEM]),',1,Red'"
		WAIT 5 { SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(vdvTP)], "'^BCB-',ITOA(nTXT_BTN[nITEM]),',1,White'" }
	    }
	}
    }
}

(**************************************************)
(* THIS FUNCTION SETS UP A MONITORED CONNECTION   *)
(* BETWEEN TWO TPS.				  *)
(* IT ALSO CONTROLS THE STATUS ICON ON THE TP 	  *)
(* SCREENS.					  *)
(**************************************************)
DEFINE_FUNCTION MONITOR_SETUP(DEV vdvTP_SOURCE, DEV vdvTP_DEST)
{
    STACK_VAR INTEGER PB_IDX1	// PHONE BOOK ENTRY INDEX OF THE MIC-ENABLED TP (TP_TALK)
    STACK_VAR INTEGER PB_IDX2	// PHONE BOOK ENTRY INDEX OF THE SPEAKER-ENABLED TP (TP_LISTEN)
    STACK_VAR INTEGER TP_IDX1	// vdvTP_DPS/dvTP_DPS INDEX OF THE MIC-ENABLED TP
    STACK_VAR INTEGER TP_IDX2	// vdvTP_DPS/dvTP_DPS INDEX OF THE SPEAKER-ENABLED TP

    IF (nDEBUG > 0) {SEND_STRING 0, "'MONITOR_SETUP(',ITOA(vdvTP_SOURCE.Number),',',ITOA(vdvTP_DEST.Number),')'"}

    PB_IDX1 = FIND_PHONEBOOK_ENTRY(vdvTP_SOURCE)
    PB_IDX2 = FIND_PHONEBOOK_ENTRY(vdvTP_DEST)
    TP_IDX1 = FIND_TP_CONNECTION(vdvTP_SOURCE)
    TP_IDX2 = FIND_TP_CONNECTION(vdvTP_DEST)
    IF (PB_IDX1 > 0 && PB_IDX2 > 0 && TP_IDX1 > 0 && TP_IDX2 > 0)
    {
	STACK_VAR INTEGER nENTRY		// AVAILABLE ENTRY IN ACTIVE_CALLS LIST
	STACK_VAR INTEGER N 			// LOOP COUNTER

	nENTRY = 0

	FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
	{	// GET FIRST EMPTY SLOT IN ACTIVE CALLS LIST
	    IF (uACTIVE_CALLS[N].nSOURCE == 0 && nENTRY == 0)
	    {
		nENTRY = N
		BREAK
	    }
	}
	IF (nENTRY != 0)	// AVAILABLE ENTRY IN uACTIVE_CALLS FOUND
	{
	    // UPDATE PHONE BOOK TO INDICATE BUSY TPS
	    uPHONE_BOOK[PB_IDX1].bACTIVE_CONN = nENTRY
	    uPHONE_BOOK[PB_IDX1].nDESTINATION = TP_IDX2
	    uPHONE_BOOK[PB_IDX2].bACTIVE_CONN = nENTRY
	    uPHONE_BOOK[PB_IDX2].nDESTINATION = TP_IDX1
	    // UPDATE ACTIVE CALLS LIST
	    uACTIVE_CALLS[nENTRY].nSOURCE = TP_IDX1
	    uACTIVE_CALLS[nENTRY].nDESTINATION = TP_IDX2
	    uACTIVE_CALLS[nENTRY].nTYPE = 1	// default to a monitor call

	    // source is a touch panel
	    IF (uLAST_CONNECTED[TP_IDX1].vdvDEVICE != dvDUMMY)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX2], "'CREATE_MONITOR-SOURCE,',uLAST_CONNECTED[TP_IDX1].cIP_ADDR"

		IF (uDOORBELLS[TP_IDX2].vdvDEVICE != dvDUMMY)	// if destination is a doorbell
		{
		    SEND_COMMAND dvTP_DPS[TP_IDX1],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H',uDOORBELLS[TP_IDX2].cIP_ADDR,'%Fstream_cam_wg.mjpeg%R10'";
		    SEND_COMMAND dvTP_DPS[TP_IDX1],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
		    SEND_COMMAND dvTP_DPS[TP_IDX1],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%P',cVIDEO_DYANAMIC_IMAGE";
		}
		ELSE { SEND_COMMAND dvTP_DPS[TP_IDX2], 'PPON-_IntercomMonitored' }
	    }

	    // destination is a touch panel
	    IF (uLAST_CONNECTED[TP_IDX2].vdvDEVICE != dvDUMMY)
	    {
		SEND_COMMAND vdvTP_DPS[TP_IDX1], "'CREATE_MONITOR-DESTINATION,',uLAST_CONNECTED[TP_IDX2].cIP_ADDR"
	    }
	    // destination is a doorbell
	    ELSE IF (uDOORBELLS[TP_IDX2].vdvDEVICE != dvDUMMY)
	    {
		uACTIVE_CALLS[nENTRY].nTYPE = 3	// view call
		SEND_COMMAND vdvTP_DPS[TP_IDX1], "'CREATE_MONITOR-DESTINATION,',uDOORBELLS[TP_IDX2].cIP_ADDR"
	    }
	}
	ELSE
	{
	    IF (nDEBUG > 0){SEND_STRING 0, 'WARNING: NO AVAILABLE ENTRIES IN ACTIVE CALL LIST'}
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, 'WARNING: ONE OR MORE TPs ARE NOT IN THE PHONE BOOK'}
    }
}

(************************************)
(* THIS FUNCTION CALCULATES THE     *)
(* NEXT PAGE IN THE PHONE BOOK      *)
(* AND CALLS FUNCTION DISPLAY_PAGE. *)
(* PAGING PAST THE END OF THE PHONE *)
(* BOOK CAUSES THE FIRST PAGE TO BE *)
(* DISPLAYED.                       *)
(************************************)
DEFINE_FUNCTION PAGE_DN(DEV vdvTP)
{
	STACK_VAR INTEGER nENTRY		// ENTRY IN THE PHONE BOOK ARRAY

	IF (nDEBUG > 0) {SEND_STRING 0, "'PAGE_DN(',ITOA(vdvTP.Number),')'"}
	nENTRY = FIND_PHONEBOOK_ENTRY(vdvTP)
	IF (nENTRY > 0)	// FOUND IN PHONE BOOK ARRAY
	{
		IF (nTP_COUNT > (uPHONE_BOOK[nENTRY].nCURRENT_PAGE * 5))	// IF THERE IS ANOTHER PAGE TO DISPLAY
		{
			uPHONE_BOOK[nENTRY].nCURRENT_PAGE++
			DISPLAY_PAGE(vdvTP, uPHONE_BOOK[nENTRY].nCURRENT_PAGE)
		}
		ELSE	// RE-DISPLAY FIRST PAGE
		{
			uPHONE_BOOK[nENTRY].nCURRENT_PAGE = 1
			DISPLAY_PAGE(vdvTP, uPHONE_BOOK[nENTRY].nCURRENT_PAGE)
		}
	}
	ELSE
	{
		IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'"}
	}
}

(************************************)
(* THIS FUNCTION CALCULATES THE     *)
(* PREVIOUS PAGE IN THE PHONE BOOK  *)
(* AND CALLS FUNCTION DISPLAY_PAGE. *)
(* PAGING BACKWARD PAST THE         *)
(* BEGINNING OF THE PHONE BOOK      *)
(* CAUSES THE LAST PAGE TO BE       *)
(* DISPLAYED.                       *)
(************************************)
DEFINE_FUNCTION PAGE_UP(DEV vdvTP)
{
	STACK_VAR INTEGER nENTRY		// ENTRY IN THE PHONE BOOK ARRAY

	IF (nDEBUG > 0) {SEND_STRING 0, "'PAGE_UP(',ITOA(vdvTP.Number),')'"}
	nENTRY = FIND_PHONEBOOK_ENTRY(vdvTP)
	IF (nENTRY > 0)	// FOUND IN PHONE BOOK ARRAY
	{
		IF (uPHONE_BOOK[nENTRY].nCURRENT_PAGE == 1)	// DISPLAY LAST PAGE
		{
			uPHONE_BOOK[nENTRY].nCURRENT_PAGE = TYPE_CAST(nTP_COUNT / nPB_DISPLAY_SIZE)
			IF (nTP_COUNT % nPB_DISPLAY_SIZE != 0) { uPHONE_BOOK[nENTRY].nCURRENT_PAGE++ }
			DISPLAY_PAGE(vdvTP, uPHONE_BOOK[nENTRY].nCURRENT_PAGE)
		}
		ELSE	// ANOTHER PAGE TO DISPLAY (OTHER THAN LAST)
		{
			uPHONE_BOOK[nENTRY].nCURRENT_PAGE--
			DISPLAY_PAGE(vdvTP, uPHONE_BOOK[nENTRY].nCURRENT_PAGE)
		}
	}
	ELSE
	{
		IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'"}
	}
}

(******************************************************)
(* THIS FUNCTION REMOVES AN ENTRY FROM THE PHONE BOOK.*)
(* THIS IS NECESSARY IN ORDER TO MAINTAIN PREDICTABLE *)
(* 'PAGE' BREAKS IN THE PHONE BOOK, AND TO ALLOW THE  *)
(* CALCULATION OF WHERE A PARTICULAR TOUCH PANEL FALLS*)
(* WITHIN THE PHONE BOOK PAGES.						  *)
(******************************************************)
DEFINE_FUNCTION REMOVE_PHONEBOOK_ENTRY(INTEGER nENTRY)
{
    STACK_VAR INTEGER N
    STACK_VAR INTEGER I

    IF (nDEBUG > 0) {SEND_STRING 0, "'REMOVE_PHONEBOOK_ENTRY(',ITOA(nENTRY),')'"}
    FOR (N = nENTRY; N <= MAX_LENGTH_ARRAY(uPHONE_BOOK) - 1; N++)
    {
	IF (uPHONE_BOOK[N+1].vdvDEVICE != dvDUMMY)
	{
	    STACK_VAR INTEGER nCALL	// ACTIVE CALL ENTRY INDEX

	    // MOVE NEXT PHONE BOOK ENTRY BACK ONE
	    uPHONE_BOOK[N].vdvDEVICE = uPHONE_BOOK[N+1].vdvDEVICE
	    uPHONE_BOOK[N].sNAME = uPHONE_BOOK[N+1].sNAME
	    uPHONE_BOOK[N].sMODEL = uPHONE_BOOK[N+1].sMODEL
	    uPHONE_BOOK[N].bACTIVE_CONN = uPHONE_BOOK[N+1].bACTIVE_CONN
	    uPHONE_BOOK[N].nDESTINATION = uPHONE_BOOK[N+1].nDESTINATION
	    uPHONE_BOOK[N].bCALL_PRIVACY = uPHONE_BOOK[N+1].bCALL_PRIVACY
	    uPHONE_BOOK[N].bDOOR_PRIVACY = uPHONE_BOOK[N+1].bDOOR_PRIVACY
	    uPHONE_BOOK[N].nCURRENT_PAGE = uPHONE_BOOK[N+1].nCURRENT_PAGE

	    // CLEAR NEXT PHONE BOOK ENTRY
	    uPHONE_BOOK[N+1].vdvDEVICE = dvDUMMY
	    uPHONE_BOOK[N+1].sNAME = ''
	    uPHONE_BOOK[N+1].bACTIVE_CONN = 0
	    uPHONE_BOOK[N+1].nDESTINATION = 0
	    uPHONE_BOOK[N+1].bCALL_PRIVACY = 0
	    uPHONE_BOOK[N+1].bDOOR_PRIVACY = 0
	    uPHONE_BOOK[N+1].nCURRENT_PAGE = 1
	}
	ELSE	// LAST ENTRY IN THE PHONE BOOK
	{
	    // CLEAR NEXT PHONE BOOK ENTRY
	    uPHONE_BOOK[N].vdvDEVICE = dvDUMMY
	    uPHONE_BOOK[N].sNAME = ''
	    uPHONE_BOOK[N].bACTIVE_CONN = 0
	    uPHONE_BOOK[N].nDESTINATION = 0
	    uPHONE_BOOK[N].bCALL_PRIVACY = 0
	    uPHONE_BOOK[N].bDOOR_PRIVACY = 0
	    uPHONE_BOOK[N].nCURRENT_PAGE = 1
	}
    }
}

(******************************************************)
(* THIS FUNCTION CREATES AND STARTS THE APPROPRIATE   *)
(* TIMELINE FOR A CALL.				      *)
(******************************************************)
DEFINE_FUNCTION START_TIMELINE(DEV vdvTP)
{
    STACK_VAR INTEGER TP_IDX1, TP_IDX2	// vdvTP_DPS/dvTP_DPS INDEXES FOR THE SOURCE AND DESTINATION OF A CALL
    STACK_VAR INTEGER nENTRY
    STACK_VAR LONG lTIME_TEMP[2]

    IF (nDEBUG > 0) {SEND_STRING 0, "'START_TIMELINE(',ITOA(vdvTP.NUMBER),')'"}
    nENTRY = FIND_ACTIVECALL_ENTRY(vdvTP)
    TP_IDX1 = FIND_TP_CONNECTION(vdvTP)
    IF (uACTIVE_CALLS[nENTRY].nDESTINATION != TP_IDX1) { TP_IDX2 = uACTIVE_CALLS[nENTRY].nDESTINATION }
    ELSE { TP_IDX2 = uACTIVE_CALLS[nENTRY].nSOURCE }
    IF (nENTRY > 0)
    {
	IF (uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT == 0 &&
		uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT == 0)
	{
	    lTIME_TEMP[1] = 0
	    lTIME_TEMP[2] = 0
	}
	ELSE IF (uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT == 0)
	{
	    lTIME_TEMP[1] = (uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT * nMINUTE) - (30 * nSECOND)
	    lTIME_TEMP[2] = 30 * nSECOND
	}
	ELSE IF (uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT == 0)
	{
	    lTIME_TEMP[1] = (uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT * nMINUTE) - (30 * nSECOND)
	    lTIME_TEMP[2] = 30 * nSECOND
	}
	ELSE IF (uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT <= uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT)
	{
	    lTIME_TEMP[1] = (uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT * nMINUTE) - (30 * nSECOND)
	    lTIME_TEMP[2] = 30 * nSECOND
	}
	ELSE IF (uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT <= uLAST_CONNECTED[TP_IDX2].nCALL_TIMEOUT)
	{
	    lTIME_TEMP[1] = (uLAST_CONNECTED[TP_IDX1].nCALL_TIMEOUT * nMINUTE) - (30 * nSECOND)
	    lTIME_TEMP[2] = 30 * nSECOND
	}
	ELSE
	{
	    lTIME_TEMP[1] = (nDEFAULT_CALL_TIMEOUT * nMINUTE) - (30 * nSECOND)
	    lTIME_TEMP[2] = 30 * nSECOND
	}
	IF (lTIME_TEMP[1] > 0)	// IF TIMEOUT IS 0, CONNECTION IS INFINITE
	{
	    lTIME[nENTRY][1] = lTIME_TEMP[1]
	    lTIME[nENTRY][2] = lTIME_TEMP[2]
	    IF (TIMELINE_ACTIVE(lTIMEOUT[nENTRY])) { TIMELINE_KILL(lTIMEOUT[nENTRY]) }
	    TIMELINE_CREATE(lTIMEOUT[nENTRY], lTIME[nENTRY], 2, TIMELINE_RELATIVE, TIMELINE_ONCE)
	}
    }
    ELSE { SEND_COMMAND 0, "'NO ACTIVE CALL EXISTS'" }
}

(******************************************************)
(* THIS FUNCTION SHIFTS ALL PHONEBOOK ENTRIES BACKWARD*)
(* ONE SPACE.			 							  *)
(******************************************************)
DEFINE_FUNCTION SHIFT_PHONEBOOK_ENTRY(INTEGER nENTRY)
{
    INTEGER N		// COUNTER
    INTEGER COUNT	// NUMBER OF TPS IN PHONE BOOK
    IF (nDEBUG > 0) {SEND_STRING 0, "'SHIFT_PHONEBOOK_ENTRY(',ITOA(nENTRY),')'"}

    COUNT = 0
    FOR (N = 1; N <= nMAX_TPS; N++)
    {
	IF (uPHONE_BOOK[N].vdvDEVICE != dvDUMMY) { COUNT++ }
    }

    IF (COUNT == nMAX_TPS) { SEND_STRING 0, "'WARNING: PHONE BOOK IS FULL'" }
    ELSE
    {
	FOR (N = COUNT; N >= nENTRY; N--)
	{
	    IF (uPHONE_BOOK[N+1].vdvDEVICE == dvDUMMY)
	    {
		STACK_VAR INTEGER nCALL	// ACTIVE CALL ENTRY INDEX

		// MOVE NEXT PHONE BOOK ENTRY BACK ONE
		uPHONE_BOOK[N+1].vdvDEVICE = uPHONE_BOOK[N].vdvDEVICE
		uPHONE_BOOK[N+1].sNAME = uPHONE_BOOK[N].sNAME
		uPHONE_BOOK[N+1].sMODEL = uPHONE_BOOK[N].sMODEL
		uPHONE_BOOK[N+1].bACTIVE_CONN = uPHONE_BOOK[N].bACTIVE_CONN
		uPHONE_BOOK[N+1].nDESTINATION = uPHONE_BOOK[N].nDESTINATION
		uPHONE_BOOK[N+1].bCALL_PRIVACY = uPHONE_BOOK[N].bCALL_PRIVACY
		uPHONE_BOOK[N+1].bDOOR_PRIVACY = uPHONE_BOOK[N].bDOOR_PRIVACY
		uPHONE_BOOK[N+1].nCURRENT_PAGE = uPHONE_BOOK[N].nCURRENT_PAGE

		// CLEAR NEXT PHONE BOOK ENTRY
		uPHONE_BOOK[N].vdvDEVICE = dvDUMMY
		uPHONE_BOOK[N].sNAME = ''
		uPHONE_BOOK[N].bACTIVE_CONN = 0
		uPHONE_BOOK[N].nDESTINATION = 0
		uPHONE_BOOK[N].bCALL_PRIVACY = 0
		uPHONE_BOOK[N].bDOOR_PRIVACY = 0
		uPHONE_BOOK[N].nCURRENT_PAGE = 1
	    }
	}
    }
}

DEFINE_FUNCTION TIMELINE_FIRE(INTEGER INDEX)
{
    STACK_VAR INTEGER nTP

    IF (nDEBUG > 0) {SEND_STRING 0, "'TIMELINE_FIRE(',ITOA(INDEX),') CALLED'"}

    IF ((uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nSOURCE].nCALL_TIMEOUT == 0 && uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nDESTINATION].nCALL_TIMEOUT != 0) ||
	(uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nDESTINATION].nCALL_TIMEOUT != 0 &&
	 uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nDESTINATION].nCALL_TIMEOUT < uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nSOURCE].nCALL_TIMEOUT))
    {
	nTP = uACTIVE_CALLS[INDEX].nDESTINATION
    }
    ELSE IF ((uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nDESTINATION].nCALL_TIMEOUT == 0 && uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nSOURCE].nCALL_TIMEOUT != 0) ||
	     (uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nSOURCE].nCALL_TIMEOUT != 0 &&
	      uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nDESTINATION].nCALL_TIMEOUT >= uLAST_CONNECTED[uACTIVE_CALLS[INDEX].nSOURCE].nCALL_TIMEOUT))
    {
	nTP = uACTIVE_CALLS[INDEX].nSOURCE
    }

    SWITCH(Timeline.Sequence)
    {
	CASE 1:
	{
	    SEND_COMMAND dvTP_DPS[nTP], 'PPON-_MoreTime'
	}
	CASE 2:
	{
	    END_CALL(vdvTP_DPS[nTP])
	    UPDATE_ALL_PHONEBOOKS()
	    SEND_COMMAND dvTP_DPS[nTP], 'PPOF-_MoreTime'
	}
    }
}

(*****************************************)
(* THIS FUNCTION TRANSMITS AUDIO FROM ONE*)
(* TP TO THE OTHER. THIS FUNCTION ALSO   *)
(* CONTROLS THE STATUS ICON ON THE TPS.	 *)
(*****************************************)
DEFINE_FUNCTION TRANSMIT_AUDIO(DEV vdvTP_TALK)
{
    STACK_VAR INTEGER PB_IDX	// PHONE BOOK ENTRY OF TALKING DEVICE
    STACK_VAR INTEGER TP_IDX	// vdvTP_DPS/dvTP_DPS INDEX OF DEVICE
    STACK_VAR INTEGER nENTRY 	// ACTIVE CALL INDEX

    IF (nDEBUG > 0) {SEND_STRING 0, "'TRANSMIT_AUDIO(',ITOA(vdvTP_TALK.Number),')'"}

    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP_TALK)
    TP_IDX = FIND_TP_CONNECTION(vdvTP_TALK)
    nENTRY = uPHONE_BOOK[PB_IDX].bACTIVE_CONN

    IF (PB_IDX > 0 && TP_IDX > 0 && nENTRY > 0)
    {
	STACK_VAR INTEGER nDEST	// vdvTP_DPS/dvTP_DPS ENTRY OF LISTENING TP

	IF (uACTIVE_CALLS[nENTRY].nSOURCE == TP_IDX) { nDEST = uACTIVE_CALLS[nENTRY].nDESTINATION }
	ELSE { nDEST = uACTIVE_CALLS[nENTRY].nSOURCE }

//	nDEST = uPHONE_BOOK[PB_IDX].nDESTINATION

	IF (nDEST > 0)
	{
	    SEND_COMMAND vdvTP_DPS[nDEST], 'ENABLE_SPEAKER'
		
	    IF (LEFT_STRING(uLAST_CONNECTED[nDEST].sMODEL,3) != 'MET')
	    {
			SEND_COMMAND dvTP_DPS[nDEST], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Connected to ',uPHONE_BOOK[PB_IDX].sNAME"
			SEND_COMMAND dvTP_DPS[nDEST],"'^RFR-',cVIDEO_DYANAMIC_IMAGE"
	    }
		SEND_COMMAND vdvTP_TALK, 'ENABLE_MIC'
	    IF (LEFT_STRING(uPHONE_BOOK[PB_IDX].sMODEL,3) != 'MET')
	    {
			SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[PB_IDX].vdvDEVICE)], "'^TXT-', ITOA(nTXT_BTN[8]),
						',0,Connected to ',uLAST_CONNECTED[nDEST].sNAME"
			SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[PB_IDX].vdvDEVICE)],"'^RFR-',cVIDEO_DYANAMIC_IMAGE"
	    }
	}
	ELSE IF (uACTIVE_CALLS[nENTRY].nTYPE != 3)	// BROAD CAST CALL
	{
	    STACK_VAR INTEGER N		// COUNTER
	    STACK_VAR INTEGER IDX

	    FOR(N = 1; N <= nTP_COUNT; N++)
	    {
			// IF PRIORITY PAGE IS ON, THEN WE DO NOT CARE ABOUT EXISTING CALLS OR PRIVACY
			// IF PRIORITY PAGE IS OFF, THEN WE DO NOT INTERRUPT EXISTING CALLS OR OVERRIDE PRIVACY
			IF ((nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != vdvTP_TALK && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY) ||
				(!nPAGE_PRIORITY && uPHONE_BOOK[N].vdvDEVICE != vdvTP_TALK && uPHONE_BOOK[N].vdvDEVICE != dvDUMMY &&
				!uPHONE_BOOK[N].bCALL_PRIVACY && uPHONE_BOOK[N].bACTIVE_CONN > 0 && uPHONE_BOOK[N].nDESTINATION == TP_IDX))
			{
				IDX = FIND_TP_CONNECTION(uPHONE_BOOK[N].vdvDEVICE)
				SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Receiving page from ',uPHONE_BOOK[PB_IDX].sNAME"
				SEND_COMMAND uPHONE_BOOK[N].vdvDEVICE, "'ENABLE_SPEAKER'"
			}
	    }
	    IDX = FIND_TP_CONNECTION(uPHONE_BOOK[PB_IDX].vdvDEVICE)
	    SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Sending page'"
	    SEND_COMMAND uPHONE_BOOK[PB_IDX].vdvDEVICE, "'ENABLE_MIC'"
	}
	ELSE	// VIEW CALL
	{
	    STACK_VAR INTEGER N		// COUNTER

	    FOR(N = 1; N <= nTP_COUNT; N++)
	    {
		IF (N != PB_IDX && uPHONE_BOOK[N].bACTIVE_CONN > 0)
		{
		    IF (uACTIVE_CALLS[uPHONE_BOOK[N].bACTIVE_CONN].nTYPE == 3 && uACTIVE_CALLS[uPHONE_BOOK[N].bACTIVE_CONN].nSOURCE == TP_IDX)
		    {
			SEND_COMMAND uPHONE_BOOK[N].vdvDEVICE, 'ENABLE_SPEAKER'
		    }
		}
	    }
	    SEND_COMMAND vdvTP_TALK, "'ENABLE_MIC'"
	}
    }
    ELSE
    {
	IF (nDEBUG > 0){SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP_TALK.Number),' NOT FOUND IN PHONE BOOK'"}
    }
}

(***************************************)
(* UPDATE THE INTERCOMM PHONE BOOK ON  *)
(* TOUCH PANELS TO REFLECT NEW STATES. *)
(***************************************)
DEFINE_FUNCTION UPDATE_ALL_PHONEBOOKS()
{
    STACK_VAR INTEGER N		// LOOP COUNTER

    IF (nDEBUG > 0) {SEND_STRING 0, 'UPDATE_ALL_PHONEBOOKS()'}
    FOR (N = 1; N <= nTP_COUNT; N++)
    {	// UPDATE ALL PANELS, BUT NOT COMMUNICATORS
	IF (uPHONE_BOOK[N].vdvDEVICE != dvDUMMY && LEFT_STRING(uPHONE_BOOK[N].sMODEL,3) != 'MET' )
	{
	    DISPLAY_PAGE(uPHONE_BOOK[N].vdvDEVICE, uPHONE_BOOK[N].nCURRENT_PAGE)
	}
    }
}

DEFINE_FUNCTION UPDATE_ALL_DOOR_PAGES()
{
    STACK_VAR INTEGER N		// LOOP COUNTER
    STACK_VAR INTEGER I		// LOOP COUNTER
    STACK_VAR INTEGER COUNT
    STACK_VAR DEV dvTP

    IF (nDEBUG > 0) {SEND_STRING 0, 'UPDATE_ALL_DOOR_PAGES()'}
    COUNT = 1
    FOR (N = 1; N <= MAX_LENGTH_ARRAY(uDOORBELLS) && COUNT <= nDOOR_DISPLAY_SIZE; N++)
    {
	IF (uDOORBELLS[N].vdvDEVICE != dvDUMMY)
	{
	    FOR (I = 1; I <= MAX_LENGTH_ARRAY(uPHONE_BOOK); I++)
	    {
		IF (uPHONE_BOOK[I].vdvDEVICE != dvDUMMY && LEFT_STRING(uPHONE_BOOK[I].sMODEL,3) != 'MET')
		{
		    dvTP = dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[I].vdvDEVICE)]
		    SEND_COMMAND dvTP, "'^TXT-',ITOA(nDOOR_TXT_BTN[COUNT+5]),',0,',uDOORBELLS[N].sNAME"
		}
		ELSE IF (uPHONE_BOOK[I].vdvDEVICE == dvDUMMY) { BREAK }
	    }
	    COUNT++
	}
    }

    WHILE (COUNT <= nDOOR_DISPLAY_SIZE)
    {
	FOR (I = 1; I < MAX_LENGTH_ARRAY(uPHONE_BOOK); I++)
	{// UPDATE ALL PANELS, BUT NOT COMMUNICATORS
	    IF (uPHONE_BOOK[I].vdvDEVICE != dvDUMMY && LEFT_STRING(uPHONE_BOOK[I].sMODEL,3) != 'MET')
	    {
		dvTP = dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[I].vdvDEVICE)]
		SEND_COMMAND dvTP, "'^TXT-',ITOA(nDOOR_TXT_BTN[COUNT+5]),',0,'"
	    }
	    ELSE IF (uPHONE_BOOK[I].vdvDEVICE == dvDUMMY) { BREAK }
	}
	COUNT++
    }
}

(*************************************)
(* THIS FUNCTION ESTABLISHES A       *)
(* ONE-WAY VIEW CALL FROM A DOORBELL *)
(* TO ALL INTERESTED TPS.            *)
(*************************************)
DEFINE_FUNCTION VIEW_CALL(DEV vdvDOORBELL, DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX1, PB_IDX2	// PHONE BOOK ENTRY FOR DEVICES
    STACK_VAR INTEGER TP_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR DEVICE
    STACK_VAR INTEGER DB_IDX	// ENTRY IN dvTP_DPS/vdvTP_DPS FOR DEVICE

    IF (nDEBUG > 0) {SEND_STRING 0, "'VIEW_CALL(',ITOA(vdvDOORBELL.Number),',',ITOA(vdvTP.NUMBER),')'"}

    PB_IDX1 = FIND_PHONEBOOK_ENTRY(vdvDOORBELL)
    PB_IDX2 = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)
    DB_IDX = FIND_TP_CONNECTION(vdvDOORBELL)

    IF (PB_IDX1 > 0 && TP_IDX > 0 && PB_IDX2 > 0 && DB_IDX > 0)
    {
	STACK_VAR INTEGER nENTRY	// AVAILABLE ENTRY IN ACTIVE_CALLS LIST

	nENTRY = FIND_ACTIVE_VIEW(vdvDOORBELL)
	IF (LEFT_STRING(uPHONE_BOOK[PB_IDX1].sMODEL,3) == 'MET')	// VIEW SOURCE - DOORBELL
	{
	    STACK_VAR INTEGER N 	// LOOP COUNTER

	    IF (nENTRY == 0)	// CREATE NEW CALL
	    {
		STACK_VAR INTEGER nADDR		// AVAILABLE ENTRY IN IGMP ADDRESS LIST

		FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
		{	// GET FIRST EMPTY SLOT IN ACTIVE CALLS LIST
		    IF (uACTIVE_CALLS[N].nSOURCE == 0 && nENTRY == 0)
		    {
			nENTRY = N
			BREAK
		    }
		}
		nADDR = FIND_IGMP_ADDR()
		IF (nENTRY != 0 && nADDR != 0)	// AVAILABLE ENTRY IN uACTIVE_CALLS FOUND
		{
		    // UPDATE PHONE BOOK TO INDICATE BUSY DEVICE
//		    uPHONE_BOOK[PB_IDX1].bACTIVE_CONN = nENTRY
//		    uPHONE_BOOK[PB_IDX1].nDESTINATION = 0
		    uPHONE_BOOK[PB_IDX2].bACTIVE_CONN = nENTRY
		    uPHONE_BOOK[PB_IDX2].nDESTINATION = DB_IDX
		    // UPDATE ACTIVE CALLS LIST
		    uACTIVE_CALLS[nENTRY].nSOURCE = DB_IDX
		    uACTIVE_CALLS[nENTRY].nDESTINATION = 0
		    uACTIVE_CALLS[nENTRY].nTYPE = 3
		    uACTIVE_CALLS[nENTRY].nIP_ADDR = nADDR
		    nIGMP_CALL_TRACKING[nADDR] = nENTRY

		    SEND_COMMAND vdvTP_DPS[DB_IDX], "'SEND_VIEW-',cIGMP_IP_LIST[nADDR]"
		    SEND_COMMAND vdvTP_DPS[DB_IDX], "'ENABLE_MIC'"
		}
		ELSE
		{
		    IF (nDEBUG > 0) { SEND_STRING 0, 'WARNING: NO AVAILABLE ENTRY IN ACTIVE CALL LIST' }
		}
	    }
	    ELSE {}	// CALL ALREADY EXISTS - NOTHING TO DO ON THIS SIDE
	}

	IF (LEFT_STRING(uPHONE_BOOK[PB_IDX2].sMODEL,3) != 'MET')	// TOUCH PANEL CONNECTING TO DOORBELL
	{
	    IF (nENTRY > 0)
	    {
		uPHONE_BOOK[PB_IDX2].bACTIVE_CONN = nENTRY
		uPHONE_BOOK[PB_IDX2].nDESTINATION = DB_IDX

		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H',uDOORBELLS[DB_IDX].cIP_ADDR,'%Fstream_cam_wg.mjpeg%R10'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RFR-',cVIDEO_DYANAMIC_IMAGE"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%P',cVIDEO_DYANAMIC_IMAGE"

		SEND_COMMAND vdvTP_DPS[TP_IDX], "'RECEIVE_VIEW-',cIGMP_IP_LIST[uACTIVE_CALLS[nENTRY].nIP_ADDR]"
		SEND_COMMAND vdvTP_DPS[TP_IDX], 'ENABLE_SPEAKER'
	    }
	    ELSE
	    {
		IF (nDEBUG > 0) { SEND_STRING 0, 'WARNING: ENTRY NOT FOUND IN ACTIVE VIEW LIST' }
	    }
	}
    }
    ELSE
    {
	IF (nDEBUG > 0) { SEND_STRING 0, "'DEVICE ',ITOA(vdvDOORBELL.Number),' OR DEVICE ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
    }
}

DEFINE_FUNCTION VIEW_TEARDOWN(DEV vdvTP)
{
    STACK_VAR INTEGER PB_IDX		// ENTRY IN PHONE BOOK FOR SPECIFIED DEVICE
    STACK_VAR INTEGER TP_IDX		// ENTRY IN dvTP_DPS/vdvTP_DPS FOR TOUCH PANEL

    IF (nDEBUG > 0) { SEND_STRING 0, "'VIEW_TEARDOWN(',ITOA(vdvTP.Number),')'" }

    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
    TP_IDX = FIND_TP_CONNECTION(vdvTP)

    IF (TP_IDX > 0 && PB_IDX > 0)
    {
	STACK_VAR INTEGER nENTRY	// ENTRY IN ACTIVE CALLS TO RELEASE
	STACK_VAR INTEGER N 		// LOOP COUNTER
	STACK_VAR INTEGER nCOUNT	// COUNTS NUMBER OF PANELS STILL IN VIEW CONNECTION

	nENTRY = uPHONE_BOOK[PB_IDX].bACTIVE_CONN
	if(nENTRY==0) {nENTRY = FIND_ACTIVE_VIEW(vdvTP)}
//	nENTRY = FIND_ACTIVE_VIEW(vdvTP)
	IF (nENTRY != 0)	// CALL FOUND
	{
	    SEND_COMMAND vdvTP, 'END_VIEW'

	    // UPDATE PHONE BOOK ENTRY IF NECESSARY
	    IF (uPHONE_BOOK[PB_IDX].bACTIVE_CONN == nENTRY)
	    {
		uPHONE_BOOK[PB_IDX].bACTIVE_CONN = 0
		uPHONE_BOOK[PB_IDX].nDESTINATION = 0
	    }

	    IF (LEFT_STRING(uPHONE_BOOK[PB_IDX].sMODEL,3) != 'MET')
	    {
		SEND_COMMAND dvTP_DPS[TP_IDX], 'PPOF-_IntercomAnswerCall'
		SEND_COMMAND dvTP_DPS[TP_IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H127.0.0.1%Ftemp.mjpg%R10'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
	    }

	    nCOUNT = 0
	    FOR (N = 1; N <= nTP_COUNT; N++)
	    {
		IF (LEFT_STRING(uPHONE_BOOK[N].sMODEL,3) != 'MET' && uPHONE_BOOK[N].bACTIVE_CONN == nENTRY)	// NOT A DOORBELL
		{
		    nCOUNT++
		}
	    }

	    IF (nCOUNT == 0)// END VIEW CALL COMPLETELY
	    {
		STACK_VAR INTEGER nBELL
		STACK_VAR INTEGER nPB_BELL

		IF (uACTIVE_CALLS[nENTRY].nSOURCE != 0) { nBELL = uACTIVE_CALLS[nENTRY].nSOURCE }
		ELSE { nBELL = uACTIVE_CALLS[nENTRY].nDESTINATION }

		nPB_BELL = FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nBELL])
		IF (uPHONE_BOOK[nPB_BELL].bACTIVE_CONN == nENTRY)
		{
		    uPHONE_BOOK[nPB_BELL].bACTIVE_CONN = 0
		    uPHONE_BOOK[nPB_BELL].nDESTINATION = 0
		}
		uACTIVE_CALLS[nENTRY].nSOURCE = 0
		uACTIVE_CALLS[nENTRY].nDESTINATION = 0
		uACTIVE_CALLS[nENTRY].nTYPE = 0
		nIGMP_CALL_TRACKING[uACTIVE_CALLS[nENTRY].nIP_ADDR] = 0
		uACTIVE_CALLS[nENTRY].nIP_ADDR = 0
		SEND_COMMAND uPHONE_BOOK[nPB_BELL].vdvDEVICE, 'END_VIEW'
	    }
	    ELSE IF (LEFT_STRING(uPHONE_BOOK[PB_IDX].sMODEL,3) == 'MET')	// END VIEW CALL COMPLETELY
	    {
		STACK_VAR INTEGER nDEST
		STACK_VAR INTEGER I

		FOR (I = 1; I < nTP_COUNT; I++)
		{
		    IF (uPHONE_BOOK[I].bACTIVE_CONN == nENTRY)
		    {
			STACK_VAR INTEGER nTP

			nTP = FIND_TP_CONNECTION(uPHONE_BOOK[I].vdvDEVICE)

			SEND_COMMAND dvTP_DPS[nTP], 'PPOF-_IntercomAnswerCall'
			SEND_COMMAND dvTP_DPS[nTP],"'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
			SEND_COMMAND dvTP_DPS[nTP],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H127.0.0.1%Ftemp.mjpg%R10'";
			SEND_COMMAND dvTP_DPS[nTP],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
			SEND_COMMAND dvTP_DPS[nTP],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'";
			SEND_COMMAND dvTP_DPS[nTP],"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
			SEND_COMMAND dvTP_DPS[nTP],"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"

			SEND_COMMAND uPHONE_BOOK[I].vdvDEVICE, 'END_VIEW'

			uACTIVE_CALLS[nENTRY].nSOURCE = 0
			uACTIVE_CALLS[nENTRY].nDESTINATION = 0
			uACTIVE_CALLS[nENTRY].nTYPE = 0
			nIGMP_CALL_TRACKING[uACTIVE_CALLS[nENTRY].nIP_ADDR] = 0
			uACTIVE_CALLS[nENTRY].nIP_ADDR = 0

			uPHONE_BOOK[I].bACTIVE_CONN = 0
			uPHONE_BOOK[I].nDESTINATION = 0
		    }
		}
	    }
	}
	ELSE IF (uPHONE_BOOK[PB_IDX].bACTIVE_CONN > 0)	// CLEAR TOUCH PANEL END OF VIEW CALL ONLY
	{
	    SEND_COMMAND vdvTP, 'END_VIEW'

	    uPHONE_BOOK[PB_IDX].bACTIVE_CONN = 0
	    uPHONE_BOOK[PB_IDX].nDESTINATION = 0

	    IF (LEFT_STRING(uPHONE_BOOK[PB_IDX].sMODEL,3) != 'MET')
	    {
		SEND_COMMAND dvTP_DPS[TP_IDX], 'PPOF-_IntercomAnswerCall'
		SEND_COMMAND dvTP_DPS[TP_IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RMF-',cVIDEO_DYANAMIC_IMAGE,',%H127.0.0.1%Ftemp.mjpg%R10'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^RFR-',cVIDEO_DYANAMIC_IMAGE";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'";
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
		SEND_COMMAND dvTP_DPS[TP_IDX],"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
	    }
	}
	ELSE
	{
	    IF (nDEBUG > 0) { SEND_STRING 0, 'WARNING: NO ACTIVE VIEW FOUND IN LIST' }
	}
    }
    ELSE
    {
	IF (nDEBUG > 0) {SEND_STRING 0, "'TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'"}
    }
}

(***********************************************************)
(*                STARTUP CODE GOES BELOW                  *)
(***********************************************************)
DEFINE_START

nTP_COUNT = nMAX_TPS
//LENGTH_ARRAY(vdvTP_DPS)	// GET THE NUMBER OF DEVICES ACTUALLY IN THE SYSTEM

// NOTE: LOOPS AT STARTUP ARE NOT A GOOD IDEA.  IF TP_COUNT IS KNOWN, IT IS BETTER TO SET EACH ENTRY INDEPENDENTLY.
FOR (nCOUNTER = 1; nCOUNTER <= nMAX_TPS; nCOUNTER++)
{
	uPHONE_BOOK[nCOUNTER].vdvDEVICE = dvDUMMY
	uPHONE_BOOK[nCOUNTER].sNAME = ''
	uPHONE_BOOK[nCOUNTER].sMODEL = ''
	uPHONE_BOOK[nCOUNTER].bACTIVE_CONN = 0
	uPHONE_BOOK[nCOUNTER].nDESTINATION = 0
	uPHONE_BOOK[nCOUNTER].bCALL_PRIVACY = 0
	uPHONE_BOOK[nCOUNTER].bDOOR_PRIVACY = 0
	uPHONE_BOOK[nCOUNTER].nCURRENT_PAGE = 1

	uACTIVE_CALLS[nCOUNTER].nSOURCE = 0
	uACTIVE_CALLS[nCOUNTER].nDESTINATION = 0
	uACTIVE_CALLS[nCOUNTER].nIP_ADDR = 0
	uACTIVE_CALLS[nCOUNTER].nTYPE = 0

	uLAST_CONNECTED[nCOUNTER].vdvDEVICE = dvDUMMY
	uLAST_CONNECTED[nCOUNTER].bAUTO_ANSWER = 0
	uLAST_CONNECTED[nCOUNTER].bMONITOR = 0
	uLAST_CONNECTED[nCOUNTER].bMONITORABLE = 0
	uLAST_CONNECTED[nCOUNTER].bCALL_PRIVACY = 0
	uLAST_CONNECTED[nCOUNTER].bDOOR_PRIVACY = 0
	uLAST_CONNECTED[nCOUNTER].nCALL_TIMEOUT = 0
	uLAST_CONNECTED[nCOUNTER].sNAME = ''

	uDOORBELLS[nCOUNTER].vdvDEVICE = dvDUMMY
	uDOORBELLS[nCOUNTER].nDOOR_CHIME = 1
	uDOORBELLS[nCOUNTER].nMIC_GAIN = 0
	uDOORBELLS[nCOUNTER].nMIC_VOL = 0
	uDOORBELLS[nCOUNTER].sMODEL = ''
	uDOORBELLS[nCOUNTER].sNAME = ''
	uDOORBELLS[nCOUNTER].cIP_ADDR = ''
	uDOORBELLS[nCOUNTER].nSLIDER_ENABLE = 0

	IF (nCOUNTER <= nIGMP_COUNT) { nIGMP_CALL_TRACKING[nCOUNTER] = 0 }
}

lTIME[1] = lTIME1
lTIME[2] = lTIME2
lTIME[3] = lTIME3
lTIME[4] = lTIME4
lTIME[5] = lTIME5
lTIME[6] = lTIME6
lTIME[7] = lTIME7
lTIME[8] = lTIME8
lTIME[9] = lTIME9
lTIME[10] = lTIME10
lTIME[11] = lTIME11
lTIME[12] = lTIME12
lTIME[13] = lTIME13
lTIME[14] = lTIME14
lTIME[15] = lTIME15
lTIME[16] = lTIME16
lTIME[17] = lTIME17
lTIME[18] = lTIME18
lTIME[19] = lTIME19
lTIME[20] = lTIME20
(***********************************************************)
(*                THE EVENTS GOES BELOW                    *)
(***********************************************************)
DEFINE_EVENT

CUSTOM_EVENT[dvTP_DPS, nTXT_BTN[7], 1001]	// GET CALL TIMEOUT
{
    STACK_VAR DEV dvTP			// INDEX IN dvTP_ARRAY OF TOUCH PANEL
    STACK_VAR DEV vdvTP
    STACK_VAR INTEGER nMEMORY

    dvTP = dvTP_DPS[GET_LAST(dvTP_DPS)]
    vdvTP = vdvTP_DPS[GET_LAST(dvTP_DPS)]

    IF (nDEBUG > 0) { send_string 0, "'CUSTOM EVENT (', ITOA(dvTP.NUMBER),') CALLED WITH VALUE ', CUSTOM.TEXT" }

    nMEMORY = FIND_TP_CONNECTION(vdvTP)
    IF (nMEMORY > 0) { uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT = ATOI(CUSTOM.TEXT) }

    SEND_COMMAND dvTP, "'^TXT-',ITOA(nTXT_BTN[7]),',0,',CUSTOM.TEXT"
}

LEVEL_EVENT[dvTP_DPS,nDOOR_LVL_BTN[1]]	// DOOR MIC
{
    STACK_VAR INTEGER nTP_IDX
    STACK_VAR INTEGER nPB_IDX
    STACK_VAR INTEGER nCALL

    nTP_IDX = GET_LAST(dvTP_DPS)
    nPB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nTP_IDX])
    nCALL = uPHONE_BOOK[nPB_IDX].bACTIVE_CONN
    IF (nCALL > 0)
    {
	LOCAL_VAR INTEGER nDB_IDX
	LOCAL_VAR INTEGER nLVL

	IF (uACTIVE_CALLS[nCALL].nSOURCE != nTP_IDX) { nDB_IDX = uACTIVE_CALLS[nCALL].nSOURCE }
	ELSE { nDB_IDX = uACTIVE_CALLS[nCALL].nDESTINATION }

	IF (nDB_IDX > 0 && LEVEL.VALUE > 0)
	{
	    nLVL = LEVEL.VALUE
	    CANCEL_WAIT 'SEND NEW LEVEL'
	    WAIT 2 'SEND NEW LEVEL'
	    {
		SEND_COMMAND vdvTP_DPS[nDB_IDX], "'GAIN-',ITOA(nLVL)"
	    }
	}
    }
}

LEVEL_EVENT[dvTP_DPS,nDOOR_LVL_BTN[2]]	// DOOR SPEAKER
{
    STACK_VAR INTEGER nTP_IDX
    STACK_VAR INTEGER nPB_IDX
    STACK_VAR INTEGER nCALL

    nTP_IDX = GET_LAST(dvTP_DPS)
    nPB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nTP_IDX])
    nCALL = uPHONE_BOOK[nPB_IDX].bACTIVE_CONN
    IF (nCALL > 0)
    {
	LOCAL_VAR INTEGER nDB_IDX
	LOCAL_VAR INTEGER nLVL

	IF (uACTIVE_CALLS[nCALL].nSOURCE != nTP_IDX) { nDB_IDX = uACTIVE_CALLS[nCALL].nSOURCE }
	ELSE { nDB_IDX = uACTIVE_CALLS[nCALL].nDESTINATION }

	IF (nDB_IDX > 0 && LEVEL.VALUE > 0)
	{
	    nLVL = LEVEL.VALUE
	    CANCEL_WAIT 'SEND NEW LEVEL'
	    WAIT 2 'SEND NEW LEVEL'
	    {
		SEND_COMMAND vdvTP_DPS[nDB_IDX], "'VOLUME-',ITOA(nLVL)"
	    }
	}
    }
}

DATA_EVENT[vdvTP_DPS]
{
	ONLINE:
	{
		IF (GET_LAST(vdvTP_DPS) == 1)
		{
			SEND_COMMAND vdvTP_DPS[1], '?DEBUG'
//			SEND_COMMAND vdvTP_DPS[1], 'DEBUG-4'
		}
	}
    STRING:
    {
	STACK_VAR CHAR cCMD[25]
	STACK_VAR DEV dvTP
	STACK_VAR DEV vdvTP
	LOCAL_VAR INTEGER INDEX

	INDEX = GET_LAST(vdvTP_DPS)
	vdvTP = vdvTP_DPS[INDEX]
	dvTP = dvTP_DPS[INDEX]

	IF (INDEX > nMAX_TPS) { SEND_STRING 0, "'MAX NUMBER OF TOUCH PANELS HAS BEEN EXCEEDED. PLEASE UPDATE nMAX_TPS IN UI.AXS'" }

        IF (nDEBUG > 0) {SEND_STRING 0, "'UI FOR ',ITOA(vdvTP.NUMBER),' RECEIVED FROM COMM: ',DATA.TEXT"}
        IF(FIND_STRING(DATA.TEXT, '-', 1)) { cCMD = UPPER_STRING(REMOVE_STRING(DATA.TEXT, '-', 1)) }
        ELSE { cCMD = UPPER_STRING(DATA.TEXT) }

	SWITCH(cCMD)
        {
	    CASE 'CALL_CANCEL':
	    {
		END_CALL(vdvTP)
		UPDATE_ALL_PHONEBOOKS()
	    }
	    CASE 'CHANGE_IP-':
	    {
		uLAST_CONNECTED[INDEX].cIP_ADDR = DATA.TEXT
	    }
	    CASE 'DEBUG-': { nDEBUG = ATOI(DATA.TEXT) }
	    CASE 'DEV_OFFLINE':
	    {
		STACK_VAR INTEGER nPB_IDX

		END_ALL_CALLS(vdvTP)
		nPB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
		IF (nPB_IDX > 0)	// FOUND DEVICE IN PHONE BOOK
		{
		    REMOVE_PHONEBOOK_ENTRY(nPB_IDX)
		    UPDATE_ALL_PHONEBOOKS()
		    IF (LEFT_STRING(uPHONE_BOOK[nPB_IDX].sMODEL,3) == 'MET')
		    {
			UPDATE_ALL_DOOR_PAGES()

		    }
		}
	    }
	    CASE 'DEV_ONLINE-':
	    {
		STACK_VAR INTEGER nPB_IDX
		STACK_VAR INTEGER nCOUNT	// LOOP COUNTER
		STACK_VAR CHAR sMODEL[20]
		STACK_VAR CHAR sNAME[20]

		sMODEL = REMOVE_STRING(DATA.TEXT, ',',1)
		SET_LENGTH_ARRAY(sMODEL, LENGTH_ARRAY(sMODEL)-1)
		SEND_COMMAND vdvTP, '?NAME'
		SEND_COMMAND vdvTP, 'END_CALLS'	// END ANY CALLS THAT MAY BE UP, OR THAT THE DEVICE THINKS ARE UP

		// CLEAR TOUCH PANEL PAGES
		IF (LEFT_STRING(sMODEL,3) != 'MET')
		{
		    FOR (nCOUNT = 1; nCOUNT <= nPB_DISPLAY_SIZE; nCOUNT++)
		    {
			SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[nCOUNT]), ',0,'"
			OFF[dvTP, nDISPLAY_BTN[1+(3*(nCOUNT-1))]]
			OFF[dvTP, nDISPLAY_BTN[2+(3*(nCOUNT-1))]]
			OFF[dvTP, nDISPLAY_BTN[3+(3*(nCOUNT-1))]]

			SEND_COMMAND dvTP,"'^TXT-',itoa(nDOOR_TXT_BTN[nCOUNT+5]),',0,'"
		    }
		    // POPULATE DOOR GRAPHIC OPTIONS
		    FOR (nCOUNT = 1; nCOUNT <= MAX_LENGTH_ARRAY(strDisplayNames); nCOUNT++)
		    {
			SEND_COMMAND dvTP, "'^TXT-', ITOA(nDOOR_TXT_BTN[nCOUNT+10]), ',0,',strDisplayNames[nCOUNT]"
		    }

		    SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[8]), ',0,'"
		    SEND_COMMAND dvTP,"'^BMF-',ITOA(nDOOR_TXT_BTN[3]),',1&2,%Pnone'"
		    SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
		    SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
		    SEND_COMMAND dvTP, '@PPF-_DoorAnswerCall'
		    CLEAR_POPUPS(dvTP)
		    // Don't assume customer wants intercom page
		    // SEND_COMMAND dvTP,'PAGE-Intercomm Demo'
		    SEND_COMMAND dvTP,"'?TXT-',ITOA(nTXT_BTN[7]),',0'"
		}

		IF (LEFT_STRING(sMODEL,3) == 'MET')
		{
		    uDOORBELLS[INDEX].nSLIDER_ENABLE = 1

		    IF (uDOORBELLS[INDEX].vdvDEVICE == dvDUMMY)	// NEW COMMUNICATOR CONNECTION
		    {
			uDOORBELLS[INDEX].nDOOR_CHIME = 1
			SEND_COMMAND vdvTP, '?GAIN'
			SEND_COMMAND vdvTP, '?VOLUME'
		    }
		    ELSE	// RE-CONNECTING COMMUNICATOR
		    {	// RESTORE LAST KNOWN COMMUNICATOR VALUES
			SEND_COMMAND vdvTP, "'GAIN-',ITOA(uDOORBELLS[INDEX].nMIC_GAIN)"
			SEND_COMMAND vdvTP, "'VOLUME-',ITOA(uDOORBELLS[INDEX].nMIC_VOL)"
		    }

		    uDOORBELLS[INDEX].vdvDEVICE = vdvTP
		    uDOORBELLS[INDEX].sMODEL = sMODEL
		    uDOORBELLS[INDEX].cIP_ADDR = DATA.TEXT
		}
		ELSE // PANEL
		{
		    uLAST_CONNECTED[INDEX].vdvDEVICE = vdvTP
		    uLAST_CONNECTED[INDEX].sMODEL = sMODEL
		    uLAST_CONNECTED[INDEX].cIP_ADDR = DATA.TEXT

		    IF (uLAST_CONNECTED[INDEX].vdvDEVICE != dvDUMMY)	// RE-CONNECTING PANEL
		    {	// RESTORE LAST KNOWN PANEL VALUES
			SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[7]),',0,', ITOA(uLAST_CONNECTED[INDEX].nCALL_TIMEOUT)"
			[dvTP,nCHAN_BTN[9]] = uLAST_CONNECTED[INDEX].bCALL_PRIVACY
			[dvTP,nCHAN_BTN[21]] = uLAST_CONNECTED[INDEX].bDOOR_PRIVACY
			[dvTP,nCHAN_BTN[12]] = uLAST_CONNECTED[INDEX].bAUTO_ANSWER
			[dvTP,nCHAN_BTN[11]] = uLAST_CONNECTED[INDEX].bMONITORABLE
			[dvTP,nCHAN_BTN[10]] = uLAST_CONNECTED[INDEX].bMONITOR
		    }
		}
	    }// END CASE 'DEV_ONLINE-'
	    CASE 'GAIN-':
	    {
		STACK_VAR INTEGER CALL_IDX
		STACK_VAR INTEGER IDX
		STACK_VAR INTEGER N 	// LOOP COUNTER

		uDOORBELLS[INDEX].nMIC_GAIN = ATOI(DATA.TEXT)
		CALL_IDX = 0
		FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
		{
		    IF ((uACTIVE_CALLS[N].nSOURCE == INDEX || uACTIVE_CALLS[N].nDESTINATION == INDEX) && uACTIVE_CALLS[N].nTYPE != 3)
		    {
			CALL_IDX = N
			BREAK
		    }
		}

		IF (CALL_IDX > 0)
		{
		    IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != INDEX) { IDX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
		    ELSE { IDX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }

		    SEND_LEVEL dvTP_DPS[IDX], nDOOR_LVL_BTN[1], uDOORBELLS[INDEX].nMIC_GAIN
		    [dvTP_DPS[IDX], nDOOR_BTN[19]] = (uDOORBELLS[INDEX].nMIC_GAIN == 0)

		    IF ([dvTP_DPS[IDX],nCHAN_BTN[22]])
		    {
			SEND_LEVEL dvTP_DPS[IDX],nDOOR_LVL_BTN[1],uDOORBELLS[INDEX].nMIC_GAIN
			uDOORBELLS[INDEX].nSLIDER_ENABLE = 0
			CANCEL_WAIT 'ENABLE LEVELS'
			WAIT 3 'ENABLE LEVELS' { uDOORBELLS[INDEX].nSLIDER_ENABLE = 1 } // REMOVES UNDESIRABLE ECHO FEEDBACK
		    }
		}
	    }
	    CASE 'INCOMINGCALL-':
	    {
		IF (!nDOOR_DND)	// IF DOORBELLS NOT DISABLED
		{
		    STACK_VAR INTEGER nCOUNT
		    STACK_VAR INTEGER IDX
		    STACK_VAR INTEGER PB_IDX
		    STACK_VAR DEV dvPANEL

		    nINCOMING_CALLER = INDEX
		    PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)

		    FOR (nCOUNT = 1; nCOUNT <= MAX_LENGTH_ARRAY(uPHONE_BOOK); nCOUNT++)
		    {
			IF (LEFT_STRING(uPHONE_BOOK[nCOUNT].sMODEL,3) != 'MET' && uPHONE_BOOK[nCOUNT].vdvDEVICE != dvDUMMY &&
			    uPHONE_BOOK[nCOUNT].bDOOR_PRIVACY == 0)	// DOOR PRIVACY IS OFF
			{
			    dvPANEL = dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)]
			    IDX = uPHONE_BOOK[nCOUNT].bACTIVE_CONN
			    IF (IDX > 0)
			    {	// CALL ALREADY IN PROGRESS
				IF (uACTIVE_CALLS[IDX].nTYPE == 0)
				{
				    SEND_COMMAND dvPANEL, "'PPON-_DoorAnswerCall'"
				    SEND_COMMAND dvPANEL,"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',0'"
				    SEND_COMMAND dvPANEL,"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',1'"
				    SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uPHONE_BOOK[PB_IDX].sNAME"
				    UPDATE_ALL_PHONEBOOKS()
				    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1]))
				    {
					TIMELINE_KILL(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1])
				    }
				    TIMELINE_CREATE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1], lRING, 6, TIMELINE_RELATIVE, TIMELINE_ONCE)
				}
				// HANDLE VIEW CALLS
				ELSE IF (uACTIVE_CALLS[IDX].nTYPE == 3)
				{
				    SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uPHONE_BOOK[PB_IDX].sNAME"

				    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1]))
				    {
					TIMELINE_KILL(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1])
				    }
				    TIMELINE_CREATE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1], lRING, 6, TIMELINE_RELATIVE, TIMELINE_ONCE)
				}
				// DON'T TERMINATE MONITOR CALLS, BUT DON'T DISPLAY DOOR BELL NOTICE TO PANEL BEING MONITORED
				ELSE IF (uACTIVE_CALLS[IDX].nTYPE == 1 && FIND_PHONEBOOK_ENTRY(vdvTP_DPS[uACTIVE_CALLS[IDX].nDESTINATION]) != nCOUNT)
				{
				    SEND_COMMAND dvPANEL, "'WAKEUP'"
				    SEND_COMMAND dvPANEL, "'PPON-_DoorAnswerCall'"
				    SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uPHONE_BOOK[PB_IDX].sNAME"

				    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1]))
				    {
					TIMELINE_KILL(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1])
				    }
				    TIMELINE_CREATE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1], lRING, 6, TIMELINE_RELATIVE, TIMELINE_ONCE)
				}
			    }
			    ELSE
			    {
				SEND_COMMAND dvPANEL, "'WAKEUP'"
				SEND_COMMAND dvPANEL, "'PPON-_DoorAnswerCall'"
				SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uPHONE_BOOK[PB_IDX].sNAME"
				IF (TIMELINE_ACTIVE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1]))
				{
				    TIMELINE_KILL(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1])
				}
				TIMELINE_CREATE(lRING_TIMEOUT[FIND_TP_CONNECTION(uPHONE_BOOK[nCOUNT].vdvDEVICE)-1], lRING, 6, TIMELINE_RELATIVE, TIMELINE_ONCE)
			    }
			}
		    }
		}
	    }// END CASE 'INCOMINGCALL'
	    CASE 'MODEL-':
	    {
		STACK_VAR INTEGER IDX

		IDX = FIND_TP_CONNECTION(vdvTP)
		IF (IDX > 0) { uLAST_CONNECTED[IDX].sMODEL = DATA.TEXT }

		IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
		IF (IDX > 0) { uPHONE_BOOK[IDX].sMODEL = DATA.TEXT }
	    }
	    CASE 'NAME-':
	    {
		STACK_VAR INTEGER IDX
		STACK_VAR INTEGER PB_IDX
		STACK_VAR INTEGER nCOUNT	// LOOP COUNTER

		//STORE_TP_CONNECTION(vdvTP)

		IDX = FIND_TP_CONNECTION(vdvTP)
		IF (IDX > 0 && uLAST_CONNECTED[IDX].vdvDEVICE != dvDUMMY) { uLAST_CONNECTED[IDX].sNAME = DATA.TEXT }
		ELSE IF (IDX > 0 && uDOORBELLS[IDX].vdvDEVICE != dvDUMMY) { uDOORBELLS[IDX].sNAME = DATA.TEXT }

		PB_IDX = FIND_PHONEBOOK_ENTRY(vdvTP)
		IF (PB_IDX > 0)
		{	// UPDATE PHONE BOOK INFO
		    uPHONE_BOOK[PB_IDX].sNAME = DATA.TEXT

		    IF (uDOORBELLS[INDEX].vdvDEVICE != dvDUMMY)
		    {
			uPHONE_BOOK[PB_IDX].vdvDEVICE = uDOORBELLS[INDEX].vdvDEVICE
			uPHONE_BOOK[PB_IDX].sMODEL = uDOORBELLS[INDEX].sMODEL
		    }
		    ELSE IF (uLAST_CONNECTED[INDEX].vdvDEVICE != dvDUMMY)
		    {
			uPHONE_BOOK[PB_IDX].vdvDEVICE = uLAST_CONNECTED[INDEX].vdvDEVICE
			uPHONE_BOOK[PB_IDX].sMODEL = uLAST_CONNECTED[INDEX].sMODEL
			uPHONE_BOOK[PB_IDX].bCALL_PRIVACY = uLAST_CONNECTED[INDEX].bCALL_PRIVACY
			uPHONE_BOOK[PB_IDX].bDOOR_PRIVACY = uLAST_CONNECTED[INDEX].bDOOR_PRIVACY
		    }

		    UPDATE_ALL_PHONEBOOKS()
		    UPDATE_ALL_DOOR_PAGES()
		}
		ELSE
		{
		    FOR (nCOUNT = 1; nCOUNT <= MAX_LENGTH_ARRAY(uPHONE_BOOK); nCOUNT++)
		    {
			IF (uPHONE_BOOK[nCOUNT].vdvDEVICE == dvDUMMY)	// INSERT AT END
			{
			    IF (uLAST_CONNECTED[IDX].vdvDEVICE != dvDUMMY) { ADD_TP_PHONEBOOK_ENTRY(nCOUNT, IDX) }
			    ELSE IF (uDOORBELLS[IDX].vdvDEVICE != dvDUMMY) { ADD_DB_PHONEBOOK_ENTRY(nCOUNT, IDX) }
			    BREAK
			}
			ELSE IF (uLAST_CONNECTED[IDX].sNAME != '' && uPHONE_BOOK[nCOUNT].sNAME > uLAST_CONNECTED[IDX].sNAME)	// INSERT IN MIDDLE
			{
			    SHIFT_PHONEBOOK_ENTRY(nCOUNT)
			    IF (uPHONE_BOOK[nCOUNT].vdvDEVICE == dvDUMMY)
			    {
				IF (uLAST_CONNECTED[IDX].vdvDEVICE != dvDUMMY) { ADD_TP_PHONEBOOK_ENTRY(nCOUNT, IDX) }
				ELSE IF (uDOORBELLS[IDX].vdvDEVICE != dvDUMMY) { ADD_DB_PHONEBOOK_ENTRY(nCOUNT, IDX) }
				BREAK
			    }
			}
			ELSE IF (uDOORBELLS[IDX].sNAME != '' && uPHONE_BOOK[nCOUNT].sNAME > uDOORBELLS[IDX].sNAME)	// INSERT IN MIDDLE
			{
			    SHIFT_PHONEBOOK_ENTRY(nCOUNT)
			    IF (uPHONE_BOOK[nCOUNT].vdvDEVICE == dvDUMMY)
			    {
				IF (uDOORBELLS[IDX].vdvDEVICE != dvDUMMY) { ADD_DB_PHONEBOOK_ENTRY(nCOUNT, IDX) }
				BREAK
			    }
			}
		    }
		}
	    }// END CASE 'NAME-'
	    CASE 'VERSION-': { SEND_STRING 0, "'VERSION-',DATA.TEXT" }
	    CASE 'VOLUME-':
	    {
		STACK_VAR INTEGER CALL_IDX
		STACK_VAR INTEGER IDX
		STACK_VAR INTEGER N 		// LOOP COUNTER

		uDOORBELLS[INDEX].nMIC_VOL = ATOI(DATA.TEXT)
		CALL_IDX = 0
		FOR (N = 1; N <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); N++)
		{
		    IF ((uACTIVE_CALLS[N].nSOURCE == INDEX || uACTIVE_CALLS[N].nDESTINATION == INDEX) && uACTIVE_CALLS[N].nTYPE != 3)
		    {
			CALL_IDX = N
			BREAK
		    }
		}
		IF (CALL_IDX > 0)
		{
		    IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != INDEX) { IDX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
		    ELSE { IDX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }

		    SEND_LEVEL dvTP_DPS[IDX], nDOOR_LVL_BTN[2], uDOORBELLS[INDEX].nMIC_VOL
		    [dvTP_DPS[IDX], nDOOR_BTN[16]] = (uDOORBELLS[INDEX].nMIC_VOL == 0)

		    IF ([dvTP_DPS[IDX],nCHAN_BTN[23]])
		    {
			SEND_LEVEL dvTP_DPS[IDX],nDOOR_LVL_BTN[2],uDOORBELLS[INDEX].nMIC_VOL
			uDOORBELLS[INDEX].nSLIDER_ENABLE = 0
			CANCEL_WAIT 'ENABLE LEVELS'
			WAIT 3 'ENABLE LEVELS' { uDOORBELLS[INDEX].nSLIDER_ENABLE = 1 } // REMOVES UNDESIRABLE ECHO FEEDBACK
		    }
		}
	    }
	}// END SWITCH(cCMD)
    }// END STRING
}// END DATA_EVENT[vdvTP_DPS]

BUTTON_EVENT[dvTP_DPS, nCHAN_BTN]
{
    PUSH:
    {
	STACK_VAR INTEGER nBTN		// INDEX IN nCHAN_BTN OF BUTTON PRESSED
	STACK_VAR DEV dvTP		// INDEX IN dvTP_ARRAY OF TOUCH PANEL
	STACK_VAR DEV vdvTP		// INDEX IN vdvTP_ARRAY OF TOUCH PANEL
	STACK_VAR INTEGER nENTRY	// PHONE BOOK ENTRY CONTAINING SPECIFIED TP
	STACK_VAR INTEGER nMEMORY	// INDEX INTO LAST CONNECTED ARRAY

	dvTP = dvTP_DPS[GET_LAST(dvTP_DPS)]
	vdvTP = vdvTP_DPS[GET_LAST(dvTP_DPS)]
	nBTN = GET_LAST(nCHAN_BTN)

	IF (nDEBUG > 0) {SEND_STRING 0, "'UI FOR ',ITOA(dvTP.NUMBER),' RECEIVED PANEL BUTTON PRESS ',ITOA(nBTN)"}

	nENTRY = FIND_PHONEBOOK_ENTRY(vdvTP)
	nMEMORY = FIND_TP_CONNECTION(vdvTP)
	if (nENTRY > 0)
	{
	    SWITCH(nBTN)
	    {
		CASE 1:		// LIST ITEM 1
		CASE 2:		// LIST ITEM 2
		CASE 3:		// LIST ITEM 3
		CASE 4:		// LIST ITEM 4
		CASE 5:		// LIST ITEM 5
		{
		    IF (LEFT_STRING(uPHONE_BOOK[nENTRY].sMODEL,3) != 'MET')	// DOES NOT APPLY TO ENTRY COMMUNICATORS - SEE BELOW
		    {
			IF ([dvTP, nCHAN_BTN[nBTN]])
			{
			    OFF[dvTP, nCHAN_BTN[nBTN]]
			    nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = 0
			}
			ELSE
			{
			    IF (nENTRY > 0)
			    {
				STACK_VAR INTEGER nITEM		// PHONE BOOK ENTRY SELECTED ON TP
				STACK_VAR INTEGER bADJUSTED		// INDICATES IF nITEM WAS ADJUSTED DUE TO nENTRY

				nITEM = (uPHONE_BOOK[nENTRY].nCURRENT_PAGE - 1) * 5 + nBTN
				IF (nENTRY <= nITEM)		// COMPENSATE FOR NOT DISPLAYING THE TP'S OWN LISTING
				{
				    nITEM++
				    ON[bADJUSTED]
				}

				OFF[dvTP,nCHAN_BTN[1]]
				OFF[dvTP,nCHAN_BTN[2]]
				OFF[dvTP,nCHAN_BTN[3]]
				OFF[dvTP,nCHAN_BTN[4]]
				OFF[dvTP,nCHAN_BTN[5]]

				// CHECK THAT BOTH TOUCH PANELS ARE AVAILABLE FOR CALLS
				IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0 AND uPHONE_BOOK[nITEM].bACTIVE_CONN == 0
				    AND uPHONE_BOOK[nITEM].bCALL_PRIVACY == 0)
				{
				    nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = nITEM
				    ON[dvTP,nCHAN_BTN[nBTN]]
				}
				ELSE IF (uPHONE_BOOK[nITEM].bCALL_PRIVACY == 1)
				{
				    SEND_COMMAND dvTP, 'PPON-_PrivacyOn'
				}
				ELSE IF (uPHONE_BOOK[nITEM].bACTIVE_CONN != 0)
				{
				    SEND_COMMAND dvTP, 'PPON-_NotAvailable'
				}
			    }
			}
		    }
		}// END CASE 1-5
		CASE 6:		// PAGE ALL
		{
		    // ONLY ALLOW PAGE ALL FUNCTIONALITY IF TP IS NOT CURRENTLY IN A CALL
		    IF (FIND_ACTIVECALL_ENTRY(vdvTP) == 0)
		    {
			STACK_VAR INTEGER N		// LOOP COUNTER

			ON[bPAGE_ALL_FLAG]
			TO[dvTP, nCHAN_BTN[6]]

			BROADCAST(vdvTP)
			TRANSMIT_AUDIO(vdvTP)
			UPDATE_ALL_PHONEBOOKS()
		    }
		    ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		}
		CASE 7:		// PLACE CALL
		{
		    IF (nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] > 0)
		    {
			IF (nENTRY > 0)
			{
			    STACK_VAR INTEGER bADJUSTED	// INDICATES IF nITEM WAS ADJUSTED DUE TO nENTRY

			    OFF[bADJUSTED]
			    // COMPENSATE FOR NOT DISPLAYING THE TP'S OWN LISTING
			    IF (nENTRY <= nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]) { ON[bADJUSTED] }
			    // CAN NOT MAKE CALLS TO ENTRY COMMUNICATORS
			    IF (LEFT_STRING(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].sMODEL,3) != 'MET')
			    {
				// CHECK THAT BOTH TOUCH PANELS ARE NOT ALREADY IN CALLS
				IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0 AND uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].bACTIVE_CONN == 0
				    AND uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].bCALL_PRIVACY == 0)
				{
				    STACK_VAR INTEGER IDX

				    IDX = FIND_TP_CONNECTION(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)
				    CALL_SETUP(vdvTP, uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)
				    IF (uLAST_CONNECTED[IDX].bAUTO_ANSWER == 1)
				    {
					TRANSMIT_AUDIO(vdvTP)
					START_TIMELINE(vdvTP)
					nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = 0
				    }
				    ELSE
				    {
					SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Connecting to ',uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].sNAME"
					SEND_COMMAND dvTP_DPS[IDX], "'PPON-_IntercomAnswerCall'"
					SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[6]), ',0,',uPHONE_BOOK[nENTRY].sNAME"
					nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = nENTRY
				    }
				    UPDATE_ALL_PHONEBOOKS()
				}
				ELSE
				{
				    IF (bADJUSTED) { INDICATE_ERROR(vdvTP, nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]-1) }
				    ELSE { INDICATE_ERROR(vdvTP, nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]) }
				    nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = 0
				}
			    }
			    ELSE { SEND_COMMAND dvTP, "'ADBEEP'" }
			}
			ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		    }
		    ELSE
		    {
			SEND_STRING 0, "'WARNING: NO DESTINATION PANEL IS SELECTED'"
			INDICATE_ERROR(vdvTP,0)
		    }

		    OFF[dvTP,nCHAN_BTN[1]]
		    OFF[dvTP,nCHAN_BTN[2]]
		    OFF[dvTP,nCHAN_BTN[3]]
		    OFF[dvTP,nCHAN_BTN[4]]
		    OFF[dvTP,nCHAN_BTN[5]]
		}// END CASE 7
		CASE 8:		// END CALL
		{
		    END_CALL(vdvTP)
		    UPDATE_ALL_PHONEBOOKS()
		}
		CASE 9:	// CALL PRIVACY TOGGLE
		{
		    IF (nENTRY > 0)
		    {	// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    [dvTP, nCHAN_BTN[9]] = ![dvTP, nCHAN_BTN[9]]
			    uPHONE_BOOK[nENTRY].bCALL_PRIVACY = [dvTP, nCHAN_BTN[9]]
			    uLAST_CONNECTED[nMEMORY].bCALL_PRIVACY = [dvTP, nCHAN_BTN[9]]
			    UPDATE_ALL_PHONEBOOKS()
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(dvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 10:	// MONITOR TOGGLE
		{
		    IF (nENTRY > 0)
		    {
			// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    [dvTP, nCHAN_BTN[10]] = ![dvTP, nCHAN_BTN[10]]
			    uLAST_CONNECTED[nMEMORY].bMONITOR = [dvTP, nCHAN_BTN[10]]
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 11:	// MONITORABLE TOGGLE
		{
		    IF (nENTRY > 0)
		    {
			// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    [dvTP, nCHAN_BTN[11]] = ![dvTP, nCHAN_BTN[11]]
			    uLAST_CONNECTED[nMEMORY].bMONITORABLE = [dvTP, nCHAN_BTN[11]]
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 12:	// AUTO ANSWER TOGGLE
		{
		    IF (nENTRY > 0)
		    {
			// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    [dvTP, nCHAN_BTN[12]] = ![dvTP, nCHAN_BTN[12]]
			    uLAST_CONNECTED[nMEMORY].bAUTO_ANSWER = [dvTP, nCHAN_BTN[12]]
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 13: { PAGE_UP(vdvTP) }	// PAGE UP
		CASE 14: { PAGE_DN(vdvTP) }	// PAGE DOWN
		CASE 15:	// DECREMENT SESSION TIMEOUT
		{
		    IF (nENTRY > 0)
		    {
			// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    IF (uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT > 0)
			    {
				uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT--
				SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[7]), ',0,',ITOA(uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT)"
			    }
			    ELSE { SEND_COMMAND dvTP, "'ADBEEP'" }
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(dvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 16:	// INCREMENT SESSION TIMEOUT
		{
		    IF (nENTRY > 0)
		    {
			// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    IF (uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT < 30)
			    {
				uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT++
				SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[7]), ',0,',ITOA(uLAST_CONNECTED[nMEMORY].nCALL_TIMEOUT)"
			    }
			    ELSE { SEND_COMMAND dvTP, "'ADBEEP'" }
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(dvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 17:	// INCOMING CALL - ANSWER
		{
		    STACK_VAR INTEGER nCALL

		    TRANSMIT_AUDIO(vdvTP)
		    START_TIMELINE(vdvTP)
		    nCALL = FIND_ACTIVECALL_ENTRY(vdvTP)
		    nCURRENTLY_SELECTED[uACTIVE_CALLS[nCALL].nSOURCE] = 0
		    nCURRENTLY_SELECTED[uACTIVE_CALLS[nCALL].nDESTINATION] = 0
		}
		CASE 18:	// INCOMING CALL - IGNORE
		{
		    STACK_VAR INTEGER IDX

		    END_CALL(vdvTP)
		    IDX = FIND_TP_CONNECTION(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)
		    SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Call Rejected'"
		    UPDATE_ALL_PHONEBOOKS()
		    WAIT 5
		    {
			SEND_COMMAND dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)],"'^TXT-',ITOA(nTXT_BTN[8]),',0,'"
			nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = 0
		    }
		}
		CASE 19:	// PLACE A MONITOR CALL
		{
		    IF (nENTRY > 0 && nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] > 0)
		    {
			STACK_VAR INTEGER bADJUSTED	// INDICATES IF nITEM WAS ADJUSTED DUE TO nENTRY
			STACK_VAR INTEGER IDX		// vdvTP_DPS/dvTP_DPS INDEX

			IDX = FIND_TP_CONNECTION(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)
			OFF[bADJUSTED]
			IF (nENTRY <= nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)])	// COMPENSATE FOR NOT DISPLAYING THE TP'S OWN LISTING
			{
			    ON[bADJUSTED]
			}
			// CHECK THAT BOTH TOUCH PANELS ARE NOT ALREADY IN CALLS AND MONITORING SETTINGS ARE VALID
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0 AND uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].bACTIVE_CONN == 0
			    AND uLAST_CONNECTED[IDX].bMONITORABLE == 1 AND uLAST_CONNECTED[nMEMORY].bMONITOR == 1)
			{
			    MONITOR_SETUP(vdvTP,uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)
			    TRANSMIT_AUDIO(uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].vdvDEVICE)

			    SEND_COMMAND dvTP_DPS[IDX], "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Monitored by ',uPHONE_BOOK[nENTRY].sNAME"
			    SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Monitoring ',uPHONE_BOOK[nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]].sNAME"
			    UPDATE_ALL_PHONEBOOKS()
			}
			ELSE
			{
			    IF (bADJUSTED) { INDICATE_ERROR(vdvTP, nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]-1) }
			    ELSE { INDICATE_ERROR(vdvTP, nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)]) }
			}
			nCURRENTLY_SELECTED[GET_LAST(dvTP_DPS)] = 0
		    }
		    ELSE
		    {
			SEND_STRING 0, "'WARNING: NO DESTINATION PANEL IS SELECTED'"
			INDICATE_ERROR(vdvTP,0)
		    }
		    OFF[dvTP,nCHAN_BTN[1]]
		    OFF[dvTP,nCHAN_BTN[2]]
		    OFF[dvTP,nCHAN_BTN[3]]
		    OFF[dvTP,nCHAN_BTN[4]]
		    OFF[dvTP,nCHAN_BTN[5]]
		}// END CASE 19
		CASE 20:	// EXTEND CALL
		{
		    STACK_VAR INTEGER nINDEX

		    nINDEX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    TIMELINE_PAUSE(lTIMEOUT[nINDEX])
		    lTIME[nINDEX][1] = lTIME[nINDEX][1] + (30 * nSECOND)
		    TIMELINE_SET(lTIMEOUT[nINDEX],0)
		    TIMELINE_RESTART(lTIMEOUT[nINDEX])
		}// END CASE 20
		CASE 21:	// DOOR PRIVACY TOGGLE
		{
		    IF (nENTRY > 0)
		    {	// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    [dvTP, nCHAN_BTN[21]] = ![dvTP, nCHAN_BTN[21]]
			    uPHONE_BOOK[nENTRY].bDOOR_PRIVACY = [dvTP, nCHAN_BTN[21]]
			    uLAST_CONNECTED[nMEMORY].bDOOR_PRIVACY = [dvTP, nCHAN_BTN[21]]
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(vdvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 22:	// DOOR MIC LEVEL
		{
		    STACK_VAR INTEGER nTP_IDX
		    STACK_VAR INTEGER nCALL

		    nTP_IDX = GET_LAST(dvTP_DPS)
		    nCALL = uPHONE_BOOK[nENTRY].bACTIVE_CONN
		    IF (nCALL > 0)
		    {
			STACK_VAR INTEGER nDB_IDX

			IF (uACTIVE_CALLS[nCALL].nSOURCE != nTP_IDX) { nDB_IDX = uACTIVE_CALLS[nCALL].nSOURCE }
			ELSE { nDB_IDX = uACTIVE_CALLS[nCALL].nDESTINATION }

			IF (nDB_IDX > 0)
			{
			    ON[BUTTON.INPUT]
			    SEND_LEVEL BUTTON.INPUT.DEVICE,nDOOR_LVL_BTN[1],uDOORBELLS[nDB_IDX].nMIC_GAIN
			}
		    }
		}
		CASE 23:	// DOOR SPEAKER LEVEL
		{
		    STACK_VAR INTEGER nTP_IDX
		    STACK_VAR INTEGER nCALL

		    nTP_IDX = GET_LAST(dvTP_DPS)
		    nCALL = uPHONE_BOOK[nENTRY].bACTIVE_CONN

		    IF (nCALL > 0)
		    {
			STACK_VAR INTEGER nDB_IDX

			IF (uACTIVE_CALLS[nCALL].nSOURCE != nTP_IDX) { nDB_IDX = uACTIVE_CALLS[nCALL].nSOURCE }
			ELSE { nDB_IDX = uACTIVE_CALLS[nCALL].nDESTINATION }

			IF (nDB_IDX > 0)
			{
			    ON[BUTTON.INPUT]
			    SEND_LEVEL BUTTON.INPUT.DEVICE,nDOOR_LVL_BTN[2],uDOORBELLS[nDB_IDX].nMIC_VOL
			}
		    }
		}
	    }// END SWITCH(nBTN)
	}// END IF (nENTRY > 0)
    }// END PUSH
    RELEASE:
    {
	STACK_VAR INTEGER nBTN		// INDEX IN nCHAN_BTN OF BUTTON PRESSED
	STACK_VAR DEV dvTP		// INDEX IN dvTP_ARRAY OF TOUCH PANEL

	dvTP = dvTP_DPS[GET_LAST(dvTP_DPS)]
	nBTN = GET_LAST(nCHAN_BTN)

	IF (nDEBUG > 0) {SEND_STRING 0, "'UI FOR ',ITOA(dvTP.NUMBER),' RECEIVED BUTTON RELEASE ',ITOA(nBTN)"}

	SWITCH(nBTN)
	{
	    CASE 6:		// PAGE ALL
	    {
		STACK_VAR DEV vdvTP		// INDEX IN vdvTP_ARRAY OF TOUCH PANEL

		vdvTP = vdvTP_DPS[GET_LAST(dvTP_DPS)]

		// ONLY PERFORM THIS IF THE PAGE BUTTON WAS SUCCESSFULLY TURNED ON
		IF (FIND_PHONEBOOK_ENTRY(vdvTP) > 0 && bPAGE_ALL_FLAG)
		{
		    OFF[bPAGE_ALL_FLAG]
		    BROADCAST_TEARDOWN(vdvTP)
		    UPDATE_ALL_PHONEBOOKS()
		}
		ELSE { SEND_COMMAND dvTP, "'ADBEEP'" }
	    }
	    CASE 22: { OFF[BUTTON.INPUT] }
	    CASE 23: { OFF[BUTTON.INPUT] }
	}
    }// END RELEASE
}// END BUTTON_EVENT[dvTP_ARRAY, nCHAN_BTN]

BUTTON_EVENT[dvTP_DPS, nDOOR_BTN]
{
    PUSH:
    {
	STACK_VAR INTEGER nBTN		// INDEX IN nDOOR_BTN OF BUTTON PRESSED
	STACK_VAR DEV dvTP		// INDEX IN dvTP_ARRAY OF TOUCH PANEL
	STACK_VAR DEV vdvTP		// INDEX IN vdvTP_ARRAY OF TOUCH PANEL
	STACK_VAR INTEGER nENTRY	// PHONE BOOK ENTRY CONTAINING SPECIFIED TP
	STACK_VAR INTEGER nMEMORY	// INDEX INTO LAST CONNECTED ARRAY

	nBTN = GET_LAST(nDOOR_BTN)
	nMEMORY = GET_LAST(dvTP_DPS)
	dvTP = dvTP_DPS[nMEMORY]
	vdvTP = vdvTP_DPS[nMEMORY]

	IF (nDEBUG > 0) {SEND_STRING 0, "'UI FOR ',ITOA(dvTP.NUMBER),' RECEIVED DOOR BUTTON PRESS ',ITOA(nBTN)"}

	nENTRY = FIND_PHONEBOOK_ENTRY(vdvTP)
	if (nENTRY > 0)
	{
	    SWITCH(nBTN)
	    {
			CASE 1:	// ANSWER DOOR
			{
				STACK_VAR INTEGER DB_IDX
	
				IF (nINCOMING_CALLER == 0)
				{
					IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN != 0)
					{
						IF (uACTIVE_CALLS[uPHONE_BOOK[nENTRY].bACTIVE_CONN].nTYPE == 3)
						{
							IF (uACTIVE_CALLS[uPHONE_BOOK[nENTRY].bACTIVE_CONN].nSOURCE != 0)
							{
								nINCOMING_CALLER = uACTIVE_CALLS[uPHONE_BOOK[nENTRY].bACTIVE_CONN].nSOURCE
							}
							ELSE
							{ 
								nINCOMING_CALLER = uACTIVE_CALLS[uPHONE_BOOK[nENTRY].bACTIVE_CONN].nDESTINATION
							}
						}
					}
				}

				IF (nINCOMING_CALLER != 0)
				{
					DB_IDX = uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP_DPS[nINCOMING_CALLER])].bACTIVE_CONN
					IF (DB_IDX == 0)	// DOOR HAS NOT BEEN ANSWERED
					{
						STACK_VAR INTEGER TP_IDX
		
						TP_IDX = uPHONE_BOOK[nENTRY].bACTIVE_CONN
						IF (TP_IDX == 0) { ANSWER_DOOR(vdvTP, vdVTP_DPS[nINCOMING_CALLER]) }
						ELSE IF (TP_IDX > 0)
						{	// IF CURRENTLY IN A VIEW CALL WITH A DOORBELL THEN ANSWER THAT DOORBELL
							IF(uACTIVE_CALLS[TP_IDX].nTYPE == 3 &&
							(LEFT_STRING(uLAST_CONNECTED[uACTIVE_CALLS[TP_IDX].nSOURCE].sMODEL,3) == 'MET' ||
							LEFT_STRING(uLAST_CONNECTED[uACTIVE_CALLS[TP_IDX].nDESTINATION].sMODEL,3) == 'MET'))
							{
								STACK_VAR DEV vdvDOOR
			
								IF (LEFT_STRING(uLAST_CONNECTED[uACTIVE_CALLS[TP_IDX].nSOURCE].sMODEL,3) == 'MET')
								{
								vdvDOOR = uLAST_CONNECTED[uACTIVE_CALLS[TP_IDX].nSOURCE].vdvDEVICE
								}
								ELSE { vdvDOOR = uLAST_CONNECTED[uACTIVE_CALLS[TP_IDX].nDESTINATION].vdvDEVICE }
								END_CALL(vdvTP)
								ANSWER_DOOR(vdvTP, vdvDOOR)
							}
							ELSE
							{
								END_CALL(vdvTP)
								ANSWER_DOOR(vdvTP, vdvTP_DPS[nINCOMING_CALLER])
							}
						}
					}
					ELSE IF (uACTIVE_CALLS[DB_IDX].nTYPE == 3)	// DOOR IS BEING VIEWED
					{
						VIEW_TEARDOWN(vdvTP)
						ANSWER_DOOR(vdvTP, vdvTP_DPS[nINCOMING_CALLER])
					}
					// DOOR HAS BEEN ANSWERED
					ELSE IF (uACTIVE_CALLS[DB_IDX].nTYPE == 0)
					{
						SEND_COMMAND dvTP, "'PPON-_NotAvailable'"
					}
				}
				SEND_COMMAND dvTP, "'PPOF-_DoorAnswerCall'"
			} // END CASE 1
		CASE 2:	// VIEW DOOR
		{
		    STACK_VAR INTEGER COUNT
		    STACK_VAR INTEGER bFOUND

		    bFOUND = 0
		    FOR (COUNT = 1; COUNT <= MAX_LENGTH_ARRAY(uACTIVE_CALLS); COUNT++)
		    {
			IF (uACTIVE_CALLS[COUNT].nSOURCE == nINCOMING_CALLER || uACTIVE_CALLS[COUNT].nDESTINATION == nINCOMING_CALLER)
			{
			    IF (uACTIVE_CALLS[COUNT].nTYPE = 3)	// VIEW CALL ALREADY IN PROGRESS
			    {
				bFOUND = 1
				BREAK
			    }
			}
		    }

		    IF (bFOUND)	// JOIN EXISTING MULTI-CAST VIEW CALL
		    {
			STACK_VAR INTEGER nCOUNT
			STACK_VAR INTEGER N	// LOOP COUNTER


			nCOUNT = 0
			FOR (N = 1; N <= MAX_LENGTH_ARRAY(nIGMP_CALL_TRACKING); N++)
			{
			    IF (nIGMP_CALL_TRACKING[N] != 0) { nCOUNT++ }
			}
			IF (nCOUNT < nIGMP_COUNT)
			{
			    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[nMEMORY-1])) { TIMELINE_KILL(lRING_TIMEOUT[nMEMORY-1]) }
			    END_CALL(vdvTP)	// TERMINATE EXISTING CALL, IF ANY
			    SEND_COMMAND dvTP, "'PPON-_DoorAnswerCall'"
			    SEND_COMMAND dvTP,"'^BBR-',itoa(nDOOR_TXT_BTN[3]),',1,',cVIDEO_DYANAMIC_IMAGE"
			    SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',1'"
			    SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',0'"
			    VIEW_CALL(vdvTP_DPS[nINCOMING_CALLER],vdvTP)
			    SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Viewing ',uDOORBELLS[nINCOMING_CALLER].sNAME"
			    UPDATE_ALL_PHONEBOOKS()
			}
			ELSE { SEND_COMMAND dvTP, 'PPON-_NotAvailable' }
		    }
		    ELSE
		    {	// create multi-cast view
			IF (TIMELINE_ACTIVE(lRING_TIMEOUT[nMEMORY-1])) { TIMELINE_KILL(lRING_TIMEOUT[nMEMORY-1]) }
			END_CALL(vdvTP)	// TERMINATE EXISTING CALL, IF ANY
			SEND_COMMAND dvTP, "'PPON-_DoorAnswerCall'"
			SEND_COMMAND dvTP,"'^BBR-',itoa(nDOOR_TXT_BTN[3]),',1,',cVIDEO_DYANAMIC_IMAGE"
			SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[4]),',1'"
			SEND_COMMAND dvTP,"'^SHO-',itoa(nDOOR_TXT_BTN[5]),',0'"
			VIEW_CALL(vdvTP_DPS[nINCOMING_CALLER],vdvTP)
			SEND_COMMAND dvTP, "'^TXT-', ITOA(nTXT_BTN[8]), ',0,Viewing ',uDOORBELLS[nINCOMING_CALLER].sNAME"
			UPDATE_ALL_PHONEBOOKS()
		    }
		}
		CASE 3:	// IGNORE DOOR
		{
		    IF (TIMELINE_ACTIVE(lRING_TIMEOUT[nMEMORY-1])) { TIMELINE_KILL(lRING_TIMEOUT[nMEMORY-1]) }
		}
		CASE 4:	// DOOR CHIME 1
		CASE 5:	// DOOR CHIME 2
		CASE 6:	// DOOR CHIME 3
		CASE 7:	// DOOR CHIME 4
		CASE 8:	// DOOR CHIME 5
		CASE 9:	// DOOR CHIME 6
		{
		    PULSE[BUTTON.INPUT]
		    nDoorChimeSelected = GET_LAST(nDOOR_BTN) - 3
		}
		CASE 10: // DOOR 1
		CASE 11: // DOOR 2
		CASE 12: // DOOR 3
		CASE 13: // DOOR 4
		CASE 14: // DOOR 5
		{
		    IF (nDoorChimeSelected)
		    {
			STACK_VAR INTEGER COUNT
			STACK_VAR INTEGER IDX
			STACK_VAR INTEGER N

			PULSE[BUTTON.INPUT]
			COUNT = 0
			IDX = 0
			N = 0
			WHILE ( COUNT < (GET_LAST(nDOOR_BTN) - 9) && N <= MAX_LENGTH_ARRAY(uDOORBELLS))
			{
			    FOR (N = IDX+1; N <= MAX_LENGTH_ARRAY(uDOORBELLS); N++)
			    {
				IF (uDOORBELLS[N].vdvDEVICE != dvDUMMY)
				{
				    IDX = N
				    COUNT++
				    BREAK;
				}
			    }
			}
			IF (IDX > 0) { uDOORBELLS[IDX].nDOOR_CHIME = nDoorChimeSelected }
		    }
		}
		CASE 15:	// DOOR DND TOGGLE
		{
		    IF (nENTRY > 0)
		    {	// CAN NOT CHANGE SETTINGS WHILE IN AN ACTIVE CALL
			IF (uPHONE_BOOK[nENTRY].bACTIVE_CONN == 0)
			{
			    STACK_VAR INTEGER INDEX
			    STACK_VAR DEV dvPANEL

			    nDOOR_DND = ![dvTP, nDOOR_BTN[15]]
			    [dvTP, nDOOR_BTN[15]] = nDOOR_DND

			    FOR (INDEX = 1; INDEX <= MAX_LENGTH_ARRAY(uPHONE_BOOK); INDEX++)
			    {
				IF (uPHONE_BOOK[INDEX].vdvDEVICE != dvDUMMY)
				{
				    IF (LEFT_STRING(uPHONE_BOOK[INDEX].sMODEL,3) != 'MET')
				    {
					dvPANEL = dvTP_DPS[FIND_TP_CONNECTION(uPHONE_BOOK[INDEX].vdvDEVICE)]
					[dvPANEL,nDOOR_BTN[15]] = nDOOR_DND
				    }
				}
				ELSE { BREAK }
			    }
			    UPDATE_ALL_PHONEBOOKS()
			}
			ELSE { SEND_STRING 0, "'WARNING: CHANGES PROHIBITED DURING ACTIVE CALLS'" }
		    }
		    ELSE { SEND_STRING 0, "'WARNING: TP ',ITOA(dvTP.Number),' NOT FOUND IN PHONE BOOK'" }
		}
		CASE 16:	// DOOR SPEAKER MUTE
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			SEND_COMMAND vdvTP_DPS[INDEX], "'VOLUME-0'"
		    }
		}
		CASE 17:	// DOOR SPEAKER DECREMENT
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			IF (uDOORBELLS[INDEX].nMIC_VOL > 0) { SEND_COMMAND vdvTP_DPS[INDEX], "'VOLUME-',ITOA(uDOORBELLS[INDEX].nMIC_VOL -1)" }
		    }
		}
		CASE 18:	// DOOR SPEAKER INCREMENT
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			IF (uDOORBELLS[INDEX].nMIC_VOL < 255) { SEND_COMMAND vdvTP_DPS[INDEX], "'VOLUME-',ITOA(uDOORBELLS[INDEX].nMIC_VOL +1)" }
		    }
		}
		CASE 19:	// DOOR MIC MUTE
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			SEND_COMMAND vdvTP_DPS[INDEX], "'GAIN-0'"
		    }
		}
		CASE 20:	// DOOR MIC INCREMENT
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			IF (uDOORBELLS[INDEX].nMIC_GAIN < 255) { SEND_COMMAND vdvTP_DPS[INDEX], "'GAIN-',ITOA(uDOORBELLS[INDEX].nMIC_GAIN +1)" }
		    }
		}
		CASE 21:	// DOOR MIC DECREMENT
		{
		    STACK_VAR INTEGER INDEX
		    STACK_VAR INTEGER CALL_IDX

		    CALL_IDX = FIND_ACTIVECALL_ENTRY(vdvTP)
		    IF (CALL_IDX > 0)
		    {
			IF (uACTIVE_CALLS[CALL_IDX].nSOURCE != nMEMORY) { INDEX = uACTIVE_CALLS[CALL_IDX].nSOURCE }
			ELSE { INDEX = uACTIVE_CALLS[CALL_IDX].nDESTINATION }
			IF (uDOORBELLS[INDEX].nMIC_GAIN > 0) { SEND_COMMAND vdvTP_DPS[INDEX], "'GAIN-',ITOA(uDOORBELLS[INDEX].nMIC_GAIN -1)" }
		    }
		}
		CASE 22:	// END VIEW CALL
		{
		    STACK_VAR INTEGER IDX

		    IDX = uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvTP)].bACTIVE_CONN
		    if (IDX > 0)
		    {
			IF (uACTIVE_CALLS[IDX].nTYPE == 3) { VIEW_TEARDOWN(vdvTP) }
			ELSE { END_CALL(vdvTP) }
			UPDATE_ALL_PHONEBOOKS()
		    }
		}
		CASE 23:	// DOOR GRAPHIC 1
		CASE 24:	// DOOR GRAPHIC 2
		CASE 25:	// DOOR GRAPHIC 3
		CASE 26:	// DOOR GRAPHIC 4
		CASE 27:	// DOOR GRAPHIC 5
		CASE 28:	// DOOR GRAPHIC 6
		{
		    PULSE[BUTTON.INPUT]
		    nDoorGraphicSelected = GET_LAST(nDOOR_BTN) - 22
		}
		CASE 29: // DOOR 1
		CASE 30: // DOOR 2
		CASE 31: // DOOR 3
		CASE 32: // DOOR 4
		CASE 33: // DOOR 5
		{
		    IF (nDoorGraphicSelected)
		    {
			STACK_VAR INTEGER COUNT
			STACK_VAR INTEGER IDX
			STACK_VAR INTEGER N

			PULSE[BUTTON.INPUT]
			COUNT = 0
			IDX = 0
			N = 0
			WHILE ( COUNT < (GET_LAST(nDOOR_BTN) - 28) && N <= MAX_LENGTH_ARRAY(uDOORBELLS))
			{
			    FOR (N = IDX+1; N <= MAX_LENGTH_ARRAY(uDOORBELLS); N++)
			    {
				IF (uDOORBELLS[N].vdvDEVICE != dvDUMMY)
				{
				    IDX = N
				    COUNT++
				    BREAK;
				}
			    }
			}

			IF (IDX > 0)
			{
			    uDOORBELLS[IDX].nGRAPHIC = nDoorGraphicSelected
			    SEND_COMMAND uDOORBELLS[IDX].vdvDEVICE, "'DISPLAY-',strDisplayLocation,strDisplayNames[nDoorGraphicSelected]"
			}
		    }
		}
	    }// END SWITCH(nBTN)
	}// END IF (nENTRY > 0)
    }// END PUSH
}// END BUTTON_EVENT[dvTP_DPS, nDOOR_BTN]

TIMELINE_EVENT[lRING_TIMEOUT1]
TIMELINE_EVENT[lRING_TIMEOUT2]
TIMELINE_EVENT[lRING_TIMEOUT3]
TIMELINE_EVENT[lRING_TIMEOUT4]
TIMELINE_EVENT[lRING_TIMEOUT5]
TIMELINE_EVENT[lRING_TIMEOUT6]
TIMELINE_EVENT[lRING_TIMEOUT7]
TIMELINE_EVENT[lRING_TIMEOUT8]
TIMELINE_EVENT[lRING_TIMEOUT9]
TIMELINE_EVENT[lRING_TIMEOUT10]
TIMELINE_EVENT[lRING_TIMEOUT11]
TIMELINE_EVENT[lRING_TIMEOUT12]
TIMELINE_EVENT[lRING_TIMEOUT13]
TIMELINE_EVENT[lRING_TIMEOUT14]
TIMELINE_EVENT[lRING_TIMEOUT15]
TIMELINE_EVENT[lRING_TIMEOUT16]
TIMELINE_EVENT[lRING_TIMEOUT17]
TIMELINE_EVENT[lRING_TIMEOUT18]
TIMELINE_EVENT[lRING_TIMEOUT19]
TIMELINE_EVENT[lRING_TIMEOUT20]
{
    STACK_VAR DEV dvPANEL
    STACK_VAR DEV vdvVIRTUAL

    vdvVIRTUAL = vdvTP_DPS[TIMELINE.ID-98]
    dvPANEL = dvTP_DPS[TIMELINE.ID-98]
    SWITCH(TIMELINE.SEQUENCE)
    {
	CASE 1: { SEND_COMMAND dvPANEL,"'@SOU-',strDoorChimeNames[uDOORBELLS[nINCOMING_CALLER].nDOOR_CHIME]" }
	CASE 2: { SEND_COMMAND dvPANEL,"'@SOU-',strDoorChimeNames[uDOORBELLS[nINCOMING_CALLER].nDOOR_CHIME]" }
	CASE 3: { SEND_COMMAND dvPANEL,"'@SOU-',strDoorChimeNames[uDOORBELLS[nINCOMING_CALLER].nDOOR_CHIME]" }
	CASE 4: { SEND_COMMAND dvPANEL,"'@SOU-',strDoorChimeNames[uDOORBELLS[nINCOMING_CALLER].nDOOR_CHIME]" }
	CASE 5: { SEND_COMMAND dvPANEL,"'@SOU-',strDoorChimeNames[uDOORBELLS[nINCOMING_CALLER].nDOOR_CHIME]" }
	CASE 6:
	{
	    STACK_VAR nCALL

	    nCALL = uPHONE_BOOK[FIND_PHONEBOOK_ENTRY(vdvVIRTUAL)].bACTIVE_CONN
	    IF (nCALL > 0)
	    {
		IF (uACTIVE_CALLS[nCALL].nTYPE != 3)
		{
		    SEND_COMMAND dvPANEL,'PPOF-_DoorAnswerCall'
		}
		ELSE
		{
		    send_string 0, "'updating popup'"
		    IF (uACTIVE_CALLS[nCALL].nSOURCE != TIMELINE.ID-98)
		    {
			SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uDOORBELLS[uACTIVE_CALLS[nCALL].nSOURCE].sNAME"
		    }
		    ELSE IF (uACTIVE_CALLS[nCALL].nDESTINATION != TIMELINE.ID-98)
		    {
			SEND_COMMAND dvPANEL, "'^TXT-', ITOA(nDOOR_TXT_BTN[1]), ',0,',uDOORBELLS[uACTIVE_CALLS[nCALL].nDESTINATION].sNAME"
		    }
		}
	    }
	    ELSE { SEND_COMMAND dvPANEL,'PPOF-_DoorAnswerCall' }
	    nINCOMING_CALLER = 0
	}
    }
}

TIMELINE_EVENT[lTIMEOUT1]
TIMELINE_EVENT[lTIMEOUT2]
TIMELINE_EVENT[lTIMEOUT3]
TIMELINE_EVENT[lTIMEOUT4]
TIMELINE_EVENT[lTIMEOUT5]
TIMELINE_EVENT[lTIMEOUT6]
TIMELINE_EVENT[lTIMEOUT7]
TIMELINE_EVENT[lTIMEOUT8]
TIMELINE_EVENT[lTIMEOUT9]
TIMELINE_EVENT[lTIMEOUT10]
TIMELINE_EVENT[lTIMEOUT11]
TIMELINE_EVENT[lTIMEOUT12]
TIMELINE_EVENT[lTIMEOUT13]
TIMELINE_EVENT[lTIMEOUT14]
TIMELINE_EVENT[lTIMEOUT15]
TIMELINE_EVENT[lTIMEOUT16]
TIMELINE_EVENT[lTIMEOUT17]
TIMELINE_EVENT[lTIMEOUT18]
TIMELINE_EVENT[lTIMEOUT19]
TIMELINE_EVENT[lTIMEOUT20]
{
	TIMELINE_FIRE(TIMELINE.ID)
}
(***********************************************************)
(*            THE ACTUAL PROGRAM GOES BELOW                *)
(***********************************************************)
DEFINE_PROGRAM
(***********************************************************)
(*                     END OF PROGRAM                      *)
(*        DO NOT PUT ANY CODE BELOW THIS COMMENT           *)
(***********************************************************)